(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["libs_app"],{

/***/ "../node_modules/@mamba/app/AdminLock.html":
/*!*************************************************!*\
  !*** ../node_modules/@mamba/app/AdminLock.html ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/shared.js */ "../node_modules/svelte/shared.js");
/* harmony import */ var _mamba_pos_api_merchant_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @mamba/pos/api/merchant.js */ "../node_modules/@mamba/pos/api/merchant.js");
/* harmony import */ var _mamba_pos_api_keyboard_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @mamba/pos/api/keyboard.js */ "../node_modules/@mamba/pos/api/keyboard.js");
/* harmony import */ var _mamba_button_Button_html__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @mamba/button/Button.html */ "../node_modules/@mamba/button/Button.html");
/* harmony import */ var _Keystroke_html__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Keystroke.html */ "../node_modules/@mamba/app/Keystroke.html");
/* harmony import */ var _mnt_c_Users_frodrigues_projects_mambandroid_poc_node_modules_mamba_app_AdminLock_svelte_css__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../node_modules/@mamba/app/AdminLock.svelte.css */ "../node_modules/@mamba/app/AdminLock.svelte.css");
/* harmony import */ var _mnt_c_Users_frodrigues_projects_mambandroid_poc_node_modules_mamba_app_AdminLock_svelte_css__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_mnt_c_Users_frodrigues_projects_mambandroid_poc_node_modules_mamba_app_AdminLock_svelte_css__WEBPACK_IMPORTED_MODULE_5__);
/* node_modules/@mamba/app/AdminLock.html generated by Svelte v2.16.1 */






function data() {
  return {
    _showLockPopUp: false,
    authError: true
  };
}

;
var methods = {
  open: function open() {
    _mamba_pos_api_keyboard_js__WEBPACK_IMPORTED_MODULE_2__["default"].setKeyboardAsNumeric();
    this.set({
      _showLockPopUp: true
    });
    this.refs.password.focus();
  },
  close: function close() {
    this.set({
      _showLockPopUp: false
    });
  },
  auth: function auth() {
    var _this = this;

    var success = _mamba_pos_api_merchant_js__WEBPACK_IMPORTED_MODULE_1__["default"].checkPassword(this.refs.password.value);
    this.fire('authentication', {
      success: success
    });

    if (success) {
      this.close();
      return;
    }

    this.refs.password.value = '';
    this.refs.dialog.classList.add('shaking');
    this.refs.password.classList.add('error');
    this.refs.password.focus();
    setTimeout(function () {
      _this.refs.dialog.classList.remove('shaking');

      _this.refs.password.classList.remove('error');
    }, 820);
  }
};
var file = "node_modules/mamba/app/AdminLock.html";

function create_main_fragment(component, ctx) {
  var if_block_anchor;
  var if_block = ctx._showLockPopUp && create_if_block(component, ctx);
  return {
    c: function create() {
      if (if_block) if_block.c();
      if_block_anchor = Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["createComment"])();
    },
    m: function mount(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["insert"])(target, if_block_anchor, anchor);
    },
    p: function update(changed, ctx) {
      if (ctx._showLockPopUp) {
        if (!if_block) {
          if_block = create_if_block(component, ctx);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d: function destroy(detach) {
      if (if_block) if_block.d(detach);

      if (detach) {
        Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["detachNode"])(if_block_anchor);
      }
    }
  };
} // (1:0) {#if _showLockPopUp}


function create_if_block(component, ctx) {
  var div2, div1, div0, text1, input, text2, table, td0, text3, text4, td1, text5, td2, text6, text7;
  var button0_initial_data = {
    secondary: true,
    bgColor: "#425963",
    width: "100%"
  };
  var button0 = new _mamba_button_Button_html__WEBPACK_IMPORTED_MODULE_3__["default"]({
    root: component.root,
    store: component.store,
    slots: {
      "default": Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["createFragment"])()
    },
    data: button0_initial_data
  });
  button0.on("click", function (event) {
    component.close();
  });
  var button1_initial_data = {
    width: "100%"
  };
  var button1 = new _mamba_button_Button_html__WEBPACK_IMPORTED_MODULE_3__["default"]({
    root: component.root,
    store: component.store,
    slots: {
      "default": Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["createFragment"])()
    },
    data: button1_initial_data
  });
  button1.on("click", function (event) {
    component.auth();
  });
  var keystroke_initial_data = {
    key: "enter"
  };
  var keystroke = new _Keystroke_html__WEBPACK_IMPORTED_MODULE_4__["default"]({
    root: component.root,
    store: component.store,
    data: keystroke_initial_data
  });
  keystroke.on("keystroke", function (event) {
    component.auth();
  });
  return {
    c: function create() {
      div2 = Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["createElement"])("div");
      div1 = Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["createElement"])("div");
      div0 = Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["createElement"])("div");
      div0.textContent = "Digite a senha administrativa para continuar.";
      text1 = Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["createText"])("\n      ");
      input = Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["createElement"])("input");
      text2 = Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["createText"])("\n      ");
      table = Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["createElement"])("table");
      td0 = Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["createElement"])("td");
      text3 = Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["createText"])("Voltar");

      button0._fragment.c();

      text4 = Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["createText"])("\n        ");
      td1 = Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["createElement"])("td");
      text5 = Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["createText"])("\n        ");
      td2 = Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["createElement"])("td");
      text6 = Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["createText"])("Confirmar");

      button1._fragment.c();

      text7 = Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["createText"])("\n\n  ");

      keystroke._fragment.c();

      div0.className = "message svelte-1yxx4g6";
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["addLoc"])(div0, file, 3, 6, 94);
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["setInputType"])(input, "password");
      input.className = "svelte-1yxx4g6";
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["addLoc"])(input, file, 4, 6, 173);
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["addLoc"])(td0, file, 6, 8, 254);
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["setStyle"])(td1, "width", "4%");
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["addLoc"])(td1, file, 15, 8, 449);
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["addLoc"])(td2, file, 16, 8, 486);
      table.className = "btns-wrapper svelte-1yxx4g6";
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["addLoc"])(table, file, 5, 6, 217);
      div1.className = "dialog svelte-1yxx4g6";
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["addLoc"])(div1, file, 2, 4, 56);
      div2.className = "dialog-wrapper svelte-1yxx4g6";
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["addLoc"])(div2, file, 1, 2, 23);
    },
    m: function mount(target, anchor) {
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["insert"])(target, div2, anchor);
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["append"])(div2, div1);
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["append"])(div1, div0);
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["append"])(div1, text1);
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["append"])(div1, input);
      component.refs.password = input;
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["append"])(div1, text2);
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["append"])(div1, table);
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["append"])(table, td0);
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["append"])(button0._slotted["default"], text3);

      button0._mount(td0, null);

      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["append"])(table, text4);
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["append"])(table, td1);
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["append"])(table, text5);
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["append"])(table, td2);
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["append"])(button1._slotted["default"], text6);

      button1._mount(td2, null);

      component.refs.dialog = div1;
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["insert"])(target, text7, anchor);

      keystroke._mount(target, anchor);
    },
    d: function destroy(detach) {
      if (detach) {
        Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["detachNode"])(div2);
      }

      if (component.refs.password === input) component.refs.password = null;
      button0.destroy();
      button1.destroy();
      if (component.refs.dialog === div1) component.refs.dialog = null;

      if (detach) {
        Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["detachNode"])(text7);
      }

      keystroke.destroy(detach);
    }
  };
}

function AdminLock(options) {
  this._debugName = '<AdminLock>';

  if (!options || !options.target && !options.root) {
    throw new Error("'target' is a required option");
  }

  Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["init"])(this, options);
  this.refs = {};
  this._state = Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["assign"])(data(), options.data);
  if (!('_showLockPopUp' in this._state)) console.warn("<AdminLock> was created without expected data property '_showLockPopUp'");
  this._intro = true;
  this._fragment = create_main_fragment(this, this._state);

  if (options.target) {
    if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");

    this._fragment.c();

    this._mount(options.target, options.anchor);

    Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["flush"])(this);
  }
}

Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["assign"])(AdminLock.prototype, svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["protoDev"]);
Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["assign"])(AdminLock.prototype, methods);

AdminLock.prototype._checkReadOnly = function _checkReadOnly(newState) {};

if (false) { var _require, configure, register, reload; }

/* harmony default export */ __webpack_exports__["default"] = (AdminLock);


/***/ }),

/***/ "../node_modules/@mamba/app/AdminLock.svelte.css":
/*!*******************************************************!*\
  !*** ../node_modules/@mamba/app/AdminLock.svelte.css ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "../node_modules/@mamba/app/App.html":
/*!*******************************************!*\
  !*** ../node_modules/@mamba/app/App.html ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var core_js_modules_es_object_assign__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es.object.assign */ "../node_modules/core-js/modules/es.object.assign.js");
/* harmony import */ var core_js_modules_es_object_assign__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_assign__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es_promise__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! core-js/modules/es.promise */ "../node_modules/core-js/modules/es.promise.js");
/* harmony import */ var core_js_modules_es_promise__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_promise__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! regenerator-runtime/runtime */ "../node_modules/regenerator-runtime/runtime.js");
/* harmony import */ var regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var svelte_shared_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! svelte/shared.js */ "../node_modules/svelte/shared.js");
/* harmony import */ var _mamba_pos_api_app_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @mamba/pos/api/app.js */ "../node_modules/@mamba/pos/api/app.js");
/* harmony import */ var _mamba_pos_api_keyboard_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @mamba/pos/api/keyboard.js */ "../node_modules/@mamba/pos/api/keyboard.js");
/* harmony import */ var _includes_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./includes/index.js */ "../node_modules/@mamba/app/includes/index.js");
/* harmony import */ var _AdminLock_html__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./AdminLock.html */ "../node_modules/@mamba/app/AdminLock.html");
/* harmony import */ var _mnt_c_Users_frodrigues_projects_mambandroid_poc_node_modules_mamba_app_App_svelte_css__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../node_modules/@mamba/app/App.svelte.css */ "../node_modules/@mamba/app/App.svelte.css");
/* harmony import */ var _mnt_c_Users_frodrigues_projects_mambandroid_poc_node_modules_mamba_app_App_svelte_css__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_mnt_c_Users_frodrigues_projects_mambandroid_poc_node_modules_mamba_app_App_svelte_css__WEBPACK_IMPORTED_MODULE_8__);




function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

/* node_modules/@mamba/app/App.html generated by Svelte v2.16.1 */






function data() {
  return {
    navigable: {
      home: true,
      back: true
    },
    navigableRoute: {
      routeBack: undefined,
      paramsBack: undefined
    },
    shortcuts: true,
    scrollable: true,
    hideAppBar: false,
    askPasswordOnClose: false
  };
}

;
var methods = {
  hideAppBar: function hideAppBar(isHideAppBar) {
    this.set({
      hideAppBar: isHideAppBar || false
    });
  },
  setShortcuts: function setShortcuts(isEnabled) {
    this.set({
      shortcuts: isEnabled
    });
  },
  setScrollable: function setScrollable(isEnabled) {
    this.set({
      scrollable: isEnabled
    });
  },
  setNavigable: function setNavigable(navigable) {
    if (typeof navigable === 'boolean') {
      this.set({
        navigable: {
          home: navigable,
          back: navigable
        }
      });
    } else {
      this.set({
        navigable: Object.assign({}, this.get().navigable, {}, navigable)
      });
    }
  },
  setNavigableRoute: function setNavigableRoute(route, params) {
    if (params === void 0) {
      params = {};
    }

    if (route !== false && route && typeof route === 'string') {
      if (params && typeof params === 'object') {
        this.set({
          navigableRoute: {
            routeBack: route,
            paramsBack: params
          }
        });
      } else {
        this.set({
          navigableRoute: {
            routeBack: route
          }
        });
      }
    } else {
      this.resetRoute();
    }
  },
  resetRoute: function resetRoute() {
    this.set({
      navigableRoute: {
        routeBack: undefined
      }
    });
  },
  askAdminPassword: function askAdminPassword() {
    var _this = this;

    this.refs.adminLock.open();
    return new Promise(function (resolve) {
      var listener = _this.refs.adminLock.on('authentication', function (event) {
        if (event.success) {
          resolve(true);
          listener.cancel();
        }
      });
    });
  },

  /** Prevent default back/enter button behaviour */
  _onKeydown: function _onKeydown(e) {
    /* istanbul ignore next */
    if (false) { var isInsideApp, eventPath; }

    var keyName = _mamba_pos_api_keyboard_js__WEBPACK_IMPORTED_MODULE_5__["default"].getKeyName(e.keyCode);
    /**
     * Should cancel the native actions for enter/back keys
     * if pressed anywhere but within a editable input
     * */

    if (keyName === 'back' || keyName === 'enter') {
      if (Object(_includes_index_js__WEBPACK_IMPORTED_MODULE_6__["isEditableInputOnFocus"])()) {
        return;
      }

      e.preventDefault();
      e.stopPropagation();
      return false;
    }
  },
  _onKeyup: function _onKeyup(e) {
    var keyCode = e.charCode || e.which || e.keyCode;
    /**
     * Don't control keys outside of an app scope if at the browser environment.
     * However, if a textarea/input is not focused and an action key was pressed,
     * allow it to pass through.
     * */

    /* istanbul ignore next */

    if (false) { var isInsideApp, eventPath; }

    var _hasKeystrokeToPreven = Object(_includes_index_js__WEBPACK_IMPORTED_MODULE_6__["hasKeystrokeToPrevent"])(),
        notPrevent = _hasKeystrokeToPreven.notPrevent,
        handlerContext = _hasKeystrokeToPreven.handlerContext;

    var keyName = _mamba_pos_api_keyboard_js__WEBPACK_IMPORTED_MODULE_5__["default"].getKeyName(keyCode);

    if (handlerContext === document) {
      if (e.defaultPrevented || Object(_includes_index_js__WEBPACK_IMPORTED_MODULE_6__["hasActiveHandlerFor"])(keyName)) {
        return;
      }
    }

    var _this$get = this.get(),
        shortcutsEnabled = _this$get.shortcuts;
    /**
     * Close the app if 'close' button clicked,
     * and there's no button with 'shortcut="close"'
     * */


    if (keyName === 'close') {
      e.preventDefault();

      if (!shortcutsEnabled || shortcutsEnabled && !document.querySelector('[shortcut="close"]')) {
        this.root.close();
        return;
      }
    }
    /** If the key is not mapped or a input is focused, do nothing */


    if (Object(_includes_index_js__WEBPACK_IMPORTED_MODULE_6__["isEditableInputOnFocus"])(e.target)) {
      return;
    }
    /** Handles back button */


    if (keyName === 'back') {
      /** Guarantees that the 'back' button is enabled and navigable is enabled */
      if (_mamba_pos_api_keyboard_js__WEBPACK_IMPORTED_MODULE_5__["default"].isBackspaceEnabled() && this.get().navigable.back) {
        e.preventDefault();

        if (this.root.router && this.root.router.get().context.path !== '/') {
          this.root.router.back();
        }
      }

      return;
    }
    /** Find the first element with shortcurt='keyName' */


    var shortcutEls = handlerContext.querySelectorAll("[shortcut='" + keyName + "']");
    /** If shortcuts are disabled or no shortcut element found, do nothing */

    if (!shortcutsEnabled || shortcutEls.length === 0) {
      return;
    }
    /**
     * There can be only one element assigned to a shortcut.
     * However, if there are more than one, use the last element.
     * (Useful for multiple confirmation dialogs stacked)
     */


    var shortcutEl = shortcutEls[shortcutEls.length - 1];
    /**
     * If a shortcut element was found.
     * If 'enter' was clicked, check if the shortcut element isn't already focused
     */

    if (!notPrevent && handlerContext !== document) {
      Object(_includes_index_js__WEBPACK_IMPORTED_MODULE_6__["dispatchEventOn"])(shortcutEl);
      return;
    }

    if (keyName !== 'enter' || document.activeElement !== shortcutEl) {
      Object(_includes_index_js__WEBPACK_IMPORTED_MODULE_6__["dispatchEventOn"])(shortcutEl);
    }
  }
};

function oncreate() {
  var _this2 = this;

  var root = this.root;
  /** Add the mamba-app-container class to the root element */

  this.root.options.target.classList.add('mamba-app-container'); // TODO: Deprecate this sometime

  root.on('navigation', function (isEnabled) {
    /* istanbul ignore next */
    if (true) {
      console.warn("[@mamba/app] this.root.fire('navigation') is deprecated. Use this.root.meta.setNavigable()");
    }

    _this2.setNavigable(isEnabled);
  });
  root.on('shortcuts', function (isEnabled) {
    /* istanbul ignore next */
    if (true) {
      console.warn("[@mamba/app] this.root.fire('shortcuts') is deprecated. Use this.root.meta.setShortcuts()");
    }

    _this2.setShortcuts(isEnabled);
  });
  root.close =
  /*#__PURE__*/
  _asyncToGenerator(
  /*#__PURE__*/
  regeneratorRuntime.mark(function _callee() {
    var _this2$get, askPasswordOnClose, auth, closingPromise;

    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _this2$get = _this2.get(), askPasswordOnClose = _this2$get.askPasswordOnClose;

            if (!askPasswordOnClose) {
              _context.next = 7;
              break;
            }

            _context.next = 4;
            return _this2.askAdminPassword();

          case 4:
            auth = _context.sent;

            if (!(auth === false)) {
              _context.next = 7;
              break;
            }

            return _context.abrupt("return");

          case 7:
            if (!(typeof root.onClose === 'function')) {
              _context.next = 13;
              break;
            }

            closingPromise = root.onClose();
            /**
             * If the `onClose` returns a promise, let's wait for its resolution and close the app.
             * If not, return and assume the method will be responsible to close the app.
             */

            if (!(!closingPromise || typeof closingPromise.then !== 'function')) {
              _context.next = 11;
              break;
            }

            return _context.abrupt("return");

          case 11:
            _context.next = 13;
            return closingPromise;

          case 13:
            _mamba_pos_api_app_js__WEBPACK_IMPORTED_MODULE_4__["default"].close();

          case 14:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  root.on('close', function () {
    /* istanbul ignore next */
    if (true) {
      console.warn("[@mamba/app] this.root.fire('close') is deprecated. Use this.root.close()");
    }

    root.close();
  });

  var resetScroll = function resetScroll() {
    /**
     * Check for __browser__ for scrolling the virtual screen
     * instead of the <html> element
     * */
    if (false) {} else {
      window.scrollTo(0, 0);
    }
  };
  /** Needed for projects with svelte-page < v2.2.0 */

  /* istanbul ignore next */


  if (root.router) {
    root.router.on('update', function (_ref2) {
      var changed = _ref2.changed,
          previous = _ref2.previous;

      if (changed.context && previous) {
        resetScroll();
      }
    });
  } else {
    root.on('router:change', resetScroll);
  }
}

;

function onstate(_ref3) {
  var previous = _ref3.previous;

  /** Set a reference on the root component to the <App/> meta component */
  if (!previous) {
    this.root.meta = this;
  }
}

;
var file = "node_modules/mamba/app/App.html";

function create_main_fragment(component, ctx) {
  var div,
      slot_content_default = component._slotted["default"],
      text;

  function onwindowkeyup(event) {
    component._onKeyup(event);

    ;
  }

  window.addEventListener("keyup", onwindowkeyup);

  function onwindowkeydown(event) {
    component._onKeydown(event);

    ;
  }

  window.addEventListener("keydown", onwindowkeydown);
  var adminlock = new _AdminLock_html__WEBPACK_IMPORTED_MODULE_7__["default"]({
    root: component.root,
    store: component.store
  });
  component.refs.adminLock = adminlock;
  return {
    c: function create() {
      div = Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_3__["createElement"])("div");
      text = Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_3__["createText"])("\n\n");

      adminlock._fragment.c();

      div.className = "mamba-app svelte-ouiaia";
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_3__["toggleClass"])(div, "no-scroll", !ctx.scrollable);
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_3__["toggleClass"])(div, "has-appbar", ctx.hasAppbar);
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_3__["addLoc"])(div, file, 5, 0, 81);
    },
    m: function mount(target, anchor) {
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_3__["insert"])(target, div, anchor);

      if (slot_content_default) {
        Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_3__["append"])(div, slot_content_default);
      }

      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_3__["insert"])(target, text, anchor);

      adminlock._mount(target, anchor);
    },
    p: function update(changed, ctx) {
      if (changed.scrollable) {
        Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_3__["toggleClass"])(div, "no-scroll", !ctx.scrollable);
      }

      if (changed.hasAppbar) {
        Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_3__["toggleClass"])(div, "has-appbar", ctx.hasAppbar);
      }
    },
    d: function destroy(detach) {
      window.removeEventListener("keyup", onwindowkeyup);
      window.removeEventListener("keydown", onwindowkeydown);

      if (detach) {
        Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_3__["detachNode"])(div);
      }

      if (slot_content_default) {
        Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_3__["reinsertChildren"])(div, slot_content_default);
      }

      if (detach) {
        Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_3__["detachNode"])(text);
      }

      adminlock.destroy(detach);
      if (component.refs.adminLock === adminlock) component.refs.adminLock = null;
    }
  };
}

function App_1(options) {
  var _this3 = this;

  this._debugName = '<App_1>';

  if (!options || !options.target && !options.root) {
    throw new Error("'target' is a required option");
  }

  Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_3__["init"])(this, options);
  this.refs = {};
  this._state = Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_3__["assign"])(data(), options.data);
  if (!('scrollable' in this._state)) console.warn("<App_1> was created without expected data property 'scrollable'");
  if (!('hasAppbar' in this._state)) console.warn("<App_1> was created without expected data property 'hasAppbar'");
  this._intro = true;
  this._handlers.state = [onstate];
  this._slotted = options.slots || {};
  onstate.call(this, {
    changed: Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_3__["assignTrue"])({}, this._state),
    current: this._state
  });
  this._fragment = create_main_fragment(this, this._state);

  this.root._oncreate.push(function () {
    oncreate.call(_this3);

    _this3.fire("update", {
      changed: Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_3__["assignTrue"])({}, _this3._state),
      current: _this3._state
    });
  });

  if (options.target) {
    if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");

    this._fragment.c();

    this._mount(options.target, options.anchor);

    Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_3__["flush"])(this);
  }
}

Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_3__["assign"])(App_1.prototype, svelte_shared_js__WEBPACK_IMPORTED_MODULE_3__["protoDev"]);
Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_3__["assign"])(App_1.prototype, methods);

App_1.prototype._checkReadOnly = function _checkReadOnly(newState) {};

if (false) { var _require, configure, register, reload; }

/* harmony default export */ __webpack_exports__["default"] = (App_1);


/***/ }),

/***/ "../node_modules/@mamba/app/App.svelte.css":
/*!*************************************************!*\
  !*** ../node_modules/@mamba/app/App.svelte.css ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "../node_modules/@mamba/app/Keystroke.html":
/*!*************************************************!*\
  !*** ../node_modules/@mamba/app/Keystroke.html ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/shared.js */ "../node_modules/svelte/shared.js");
/* harmony import */ var _includes_KeystrokeRegister_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./includes/KeystrokeRegister.js */ "../node_modules/@mamba/app/includes/KeystrokeRegister.js");
/* node_modules/@mamba/app/Keystroke.html generated by Svelte v2.16.1 */



var onKeystroke = function onKeystroke(component) {
  return function (e) {
    return component.fire('keystroke', e);
  };
};

function data() {
  return {
    key: null,
    active: true
  };
}

;

function oncreate() {
  this._onKeystroke = onKeystroke(this);
}

;

function ondestroy() {
  Object(_includes_KeystrokeRegister_js__WEBPACK_IMPORTED_MODULE_1__["removeHandler"])(this.get().key, this._onKeystroke);
}

;

function onupdate(_ref) {
  var changed = _ref.changed,
      current = _ref.current;

  /* istanbul ignore else */
  if (changed.active) {
    if (current.active) {
      Object(_includes_KeystrokeRegister_js__WEBPACK_IMPORTED_MODULE_1__["addHandler"])(current.key, this._onKeystroke);
    } else {
      Object(_includes_KeystrokeRegister_js__WEBPACK_IMPORTED_MODULE_1__["removeHandler"])(current.key, this._onKeystroke);
    }
  }
}

;
var file = "node_modules/mamba/app/Keystroke.html";

function create_main_fragment(component, ctx) {
  return {
    c: svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["noop"],
    m: svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["noop"],
    p: svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["noop"],
    d: svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["noop"]
  };
}

function Keystroke(options) {
  var _this = this;

  this._debugName = '<Keystroke>';

  if (!options || !options.target && !options.root) {
    throw new Error("'target' is a required option");
  }

  Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["init"])(this, options);
  this._state = Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["assign"])(data(), options.data);
  this._intro = true;
  this._handlers.update = [onupdate];
  this._handlers.destroy = [ondestroy];
  this._fragment = create_main_fragment(this, this._state);

  this.root._oncreate.push(function () {
    oncreate.call(_this);

    _this.fire("update", {
      changed: Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["assignTrue"])({}, _this._state),
      current: _this._state
    });
  });

  if (options.target) {
    if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");

    this._fragment.c();

    this._mount(options.target, options.anchor);

    Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["flush"])(this);
  }
}

Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["assign"])(Keystroke.prototype, svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["protoDev"]);

Keystroke.prototype._checkReadOnly = function _checkReadOnly(newState) {};

if (false) { var _require, configure, register, reload; }

/* harmony default export */ __webpack_exports__["default"] = (Keystroke);

/***/ }),

/***/ "../node_modules/@mamba/app/includes/EventDispatcher.js":
/*!**************************************************************!*\
  !*** ../node_modules/@mamba/app/includes/EventDispatcher.js ***!
  \**************************************************************/
/*! exports provided: dispatchEventOn */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dispatchEventOn", function() { return dispatchEventOn; });
var dispatchEventOn = function dispatchEventOn(shortcutEl) {
  /**
   * Adapted from:
   * https://stackoverflow.com/questions/15739263/phantomjs-click-an-element
   */
  var event = document.createEvent('MouseEvent');
  event.initMouseEvent('click', true, true, window, null, 0, 0, 0, 0, false, false, false, false, 0, null);
  shortcutEl.dispatchEvent(event);
};

/***/ }),

/***/ "../node_modules/@mamba/app/includes/KeystrokeRegister.js":
/*!****************************************************************!*\
  !*** ../node_modules/@mamba/app/includes/KeystrokeRegister.js ***!
  \****************************************************************/
/*! exports provided: isEditableInputOnFocus, hasActiveHandlerFor, hasKeystrokeToPrevent, addHandler, removeHandler */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isEditableInputOnFocus", function() { return isEditableInputOnFocus; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hasActiveHandlerFor", function() { return hasActiveHandlerFor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hasKeystrokeToPrevent", function() { return hasKeystrokeToPrevent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addHandler", function() { return addHandler; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeHandler", function() { return removeHandler; });
/* harmony import */ var core_js_modules_web_dom_collections_for_each__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/web.dom-collections.for-each */ "../node_modules/core-js/modules/web.dom-collections.for-each.js");
/* harmony import */ var core_js_modules_web_dom_collections_for_each__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_web_dom_collections_for_each__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _mamba_pos_api_keyboard_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @mamba/pos/api/keyboard.js */ "../node_modules/@mamba/pos/api/keyboard.js");


var register = {
  length: 0
};
/** Return if a certain shortcut key is valid */

var isEditableInputOnFocus = function isEditableInputOnFocus(target) {
  var targetEl = target && target !== window.document.body ? target : document.activeElement;
  var isTextInputEl = targetEl.tagName === 'INPUT' || targetEl.tagName === 'TEXTAREA';
  var isEditable = targetEl.disabled !== true && targetEl.readOnly !== true;
  return isTextInputEl && isEditable;
};
var hasActiveHandlerFor = function hasActiveHandlerFor(key) {
  return !!register[key] && register[key].length > 0;
};
var hasKeystrokeToPrevent = function hasKeystrokeToPrevent() {
  /**
   * Get the element with focus.
   * ! This will only work with focusable elements, (ie: with tabindex = -1 or input)
   */
  // eslint-disable-next-line prefer-destructuring
  var activeElement = document.activeElement;
  var hasTarget = activeElement !== window.document.body;
  var notPrevent = hasTarget ? !(activeElement.dataset.freezeKeystrokes || false) : true;
  return {
    notPrevent: notPrevent,
    handlerContext: hasTarget ? activeElement : document
  };
};

var keystrokeHandler = function keystrokeHandler(e) {
  var keyName = _mamba_pos_api_keyboard_js__WEBPACK_IMPORTED_MODULE_1__["default"].getKeyName(e.charCode || e.which || e.keyCode);
  var keyHandlers = register[keyName]; // handlerContext: Do not execute keystroke handlers for non global(window target) events

  var _hasKeystrokeToPreven = hasKeystrokeToPrevent(e),
      notPrevent = _hasKeystrokeToPreven.notPrevent; // Check if we have a editable input with focus


  var isInputOnFocus = isEditableInputOnFocus(); // prevent back or enter keystrokes to execute simultaneously with on:submit event

  var inputEventOnFocus = isInputOnFocus && (keyName === 'back' || keyName === 'enter'); // foward close event for registered keystrokes

  var inputEventOnClose = isInputOnFocus && keyName === 'close' && hasActiveHandlerFor(keyName);

  if (inputEventOnClose || notPrevent && hasActiveHandlerFor(keyName) && !inputEventOnFocus) {
    e.preventDefault();
    e.stopImmediatePropagation();
    keyHandlers.forEach(function (handlers) {
      if (e.type !== 'keydown') {
        handlers(e);
      }
    });
  }
};

var listen = function listen() {
  return window.addEventListener('keyup', keystrokeHandler);
};

var unlisten = function unlisten() {
  return window.removeEventListener('keyup', keystrokeHandler);
};

var addHandler = function addHandler(key, handler) {
  if (key) {
    if (!register[key]) {
      if (false >= 1) {
        console.log("[@mamba/app/keystroke] Registering manual keystroke handler for \"" + key + "\"");
      }

      register[key] = [];
      /** First key in the register, let's start listening */

      if (++register.length === 1) {
        listen();
      }
    }

    register[key].push(handler);
  }
};
var removeHandler = function removeHandler(key, handler) {
  if (key && register[key]) {
    var index = register[key].indexOf(handler);

    if (index > -1) {
      register[key].splice(index, 1);

      if (false >= 1) {
        console.log("[@mamba/app/keystroke] Removing manual keystroke handler for \"" + key + "\"");
      }

      if (register[key].length === 0) {
        delete register[key];
      }
    }
    /** Was the last key on the register, let's unlisten */


    if (--register.length === 0) {
      unlisten();
    }
  }
};

/***/ }),

/***/ "../node_modules/@mamba/app/includes/index.js":
/*!****************************************************!*\
  !*** ../node_modules/@mamba/app/includes/index.js ***!
  \****************************************************/
/*! exports provided: addHandler, removeHandler, hasKeystrokeToPrevent, hasActiveHandlerFor, isEditableInputOnFocus, dispatchEventOn */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _EventDispatcher_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EventDispatcher.js */ "../node_modules/@mamba/app/includes/EventDispatcher.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dispatchEventOn", function() { return _EventDispatcher_js__WEBPACK_IMPORTED_MODULE_0__["dispatchEventOn"]; });

/* harmony import */ var _KeystrokeRegister_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./KeystrokeRegister.js */ "../node_modules/@mamba/app/includes/KeystrokeRegister.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "addHandler", function() { return _KeystrokeRegister_js__WEBPACK_IMPORTED_MODULE_1__["addHandler"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "removeHandler", function() { return _KeystrokeRegister_js__WEBPACK_IMPORTED_MODULE_1__["removeHandler"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hasKeystrokeToPrevent", function() { return _KeystrokeRegister_js__WEBPACK_IMPORTED_MODULE_1__["hasKeystrokeToPrevent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hasActiveHandlerFor", function() { return _KeystrokeRegister_js__WEBPACK_IMPORTED_MODULE_1__["hasActiveHandlerFor"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isEditableInputOnFocus", function() { return _KeystrokeRegister_js__WEBPACK_IMPORTED_MODULE_1__["isEditableInputOnFocus"]; });






/***/ }),

/***/ "../node_modules/@mamba/appbar/AppBar.html":
/*!*************************************************!*\
  !*** ../node_modules/@mamba/appbar/AppBar.html ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/shared.js */ "../node_modules/svelte/shared.js");
/* harmony import */ var _mamba_icon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @mamba/icon */ "../node_modules/@mamba/icon/Icon.html");
/* harmony import */ var _mnt_c_Users_frodrigues_projects_mambandroid_poc_node_modules_mamba_appbar_AppBar_svelte_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../node_modules/@mamba/appbar/AppBar.svelte.css */ "../node_modules/@mamba/appbar/AppBar.svelte.css");
/* harmony import */ var _mnt_c_Users_frodrigues_projects_mambandroid_poc_node_modules_mamba_appbar_AppBar_svelte_css__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_mnt_c_Users_frodrigues_projects_mambandroid_poc_node_modules_mamba_appbar_AppBar_svelte_css__WEBPACK_IMPORTED_MODULE_2__);
/* node_modules/@mamba/appbar/AppBar.html generated by Svelte v2.16.1 */



function style(_ref) {
  var bgColor = _ref.bgColor,
      textColor = _ref.textColor,
      border = _ref.border;
  return ["color:" + textColor, "background-color:" + bgColor, !border && 'border-bottom: none;'].filter(Boolean).join(';');
}

;

function _isAtHome(_ref2) {
  var _location = _ref2._location;
  return _location === '/' || !_location;
}

function _showBack(_ref3) {
  var _isAtHome = _ref3._isAtHome,
      _isNavigationEnabled = _ref3._isNavigationEnabled;
  return !_isAtHome && _isNavigationEnabled.back;
}

function _showHome(_ref4) {
  var _isNavigationEnabled = _ref4._isNavigationEnabled;
  return _isNavigationEnabled.home;
}

function data() {
  return {
    _location: undefined,
    _isNavigationEnabled: {
      back: false,
      home: true
    },
    _navigableRoute: {
      routeBack: undefined,
      paramsBack: undefined
    },
    title: undefined,
    textColor: '#425963',
    bgColor: '#f2f2f2',
    border: true,
    _hideAppBar: false
  };
}

;
var methods = {
  _goHome: function _goHome() {
    var _this$get = this.get(),
        _isAtHome = _this$get._isAtHome;

    if (_isAtHome) {
      this.root.fire('appbar:closeApp');
      return this.root.close();
    }
    /* istanbul ignore else */


    if (this.root.router) {
      this.root.fire('appbar:goHome');
      this.root.router.go('/');
    }
  },
  _goBack: function _goBack() {
    var _this$get2 = this.get(),
        _navigableRoute = _this$get2._navigableRoute;
    /* istanbul ignore else */


    if (_navigableRoute.routeBack) {
      console.log(_navigableRoute.routeBack);

      if (_navigableRoute.paramsBack) {
        this.root.router.go(_navigableRoute.routeBack, _navigableRoute.paramsBack);
      } else {
        this.root.router.go(_navigableRoute.routeBack);
      }
    } else if (this.root.router) {
      this.root.fire('appbar:goBack');
      this.root.router.back();
    }
  }
};

function oncreate() {
  var _this = this;

  var root = this.root;
  /** Listen for route changes and appbar prop changes */

  root.on('appbar:modify', function (state) {
    return _this.set(state);
  });
  /** Needed for projects with svelte-page < v2.2.0 */

  if (root.router) {
    root.router.on('update', function (_ref5) {
      var changed = _ref5.changed,
          current = _ref5.current;

      if (changed.context && current.context) {
        _this.set({
          _location: current.context.path
        });
      }
    });
  } else {
    root.on('router:change', function (context) {
      _this.set({
        _location: context.path
      });
    });
  }
  /* istanbul ignore else */


  if (root.meta) {
    root.meta.set({
      hasAppbar: true
    });
    root.meta.on('update', function (_ref6) {
      var changed = _ref6.changed,
          current = _ref6.current;

      /* istanbul ignore else */
      if (changed.navigable) {
        _this.set({
          _isNavigationEnabled: current.navigable
        });
      } else if (changed.hideAppBar) {
        _this.set({
          _hideAppBar: current.hideAppBar
        });
      } else if (changed.navigableRoute) {
        _this.set({
          _navigableRoute: current.navigableRoute
        });
      }

      if (changed.navigableRoute) {
        _this.set({
          _navigableRoute: current.navigableRoute
        });
      }
    });
  }
}

;

function ondestroy() {
  /* istanbul ignore else */
  if (this.root.meta) {
    this.root.meta.set({
      hasAppbar: false
    });
  }
}

;

function onstate(_ref7) {
  var changed = _ref7.changed,
      current = _ref7.current;

  if (changed.title) {
    document.title = current.title;
  }
}

;
var file = "node_modules/mamba/appbar/AppBar.html";

function create_main_fragment(component, ctx) {
  var if_block_anchor;
  var if_block = ctx._hideAppBar === false && create_if_block(component, ctx);
  return {
    c: function create() {
      if (if_block) if_block.c();
      if_block_anchor = Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["createComment"])();
    },
    m: function mount(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["insert"])(target, if_block_anchor, anchor);
    },
    p: function update(changed, ctx) {
      if (ctx._hideAppBar === false) {
        if (if_block) {
          if_block.p(changed, ctx);
        } else {
          if_block = create_if_block(component, ctx);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d: function destroy(detach) {
      if (if_block) if_block.d(detach);

      if (detach) {
        Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["detachNode"])(if_block_anchor);
      }
    }
  };
} // (1:0) {#if _hideAppBar === false}


function create_if_block(component, ctx) {
  var header, text0, text1;
  var if_block0 = (ctx._navigableRoute.routeBack || ctx._showBack) && create_if_block_3(component, ctx);
  var if_block1 = ctx.title && create_if_block_2(component, ctx);
  var if_block2 = ctx._showHome && create_if_block_1(component, ctx);
  return {
    c: function create() {
      header = Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["createElement"])("header");
      if (if_block0) if_block0.c();
      text0 = Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["createText"])(" ");
      if (if_block1) if_block1.c();
      text1 = Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["createText"])(" ");
      if (if_block2) if_block2.c();
      header.className = "appbar svelte-lzlsp4";
      header.style.cssText = ctx.style;
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["addLoc"])(header, file, 1, 0, 28);
    },
    m: function mount(target, anchor) {
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["insert"])(target, header, anchor);
      if (if_block0) if_block0.m(header, null);
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["append"])(header, text0);
      if (if_block1) if_block1.m(header, null);
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["append"])(header, text1);
      if (if_block2) if_block2.m(header, null);
    },
    p: function update(changed, ctx) {
      if (ctx._navigableRoute.routeBack || ctx._showBack) {
        if (if_block0) {
          if_block0.p(changed, ctx);
        } else {
          if_block0 = create_if_block_3(component, ctx);
          if_block0.c();
          if_block0.m(header, text0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }

      if (ctx.title) {
        if (if_block1) {
          if_block1.p(changed, ctx);
        } else {
          if_block1 = create_if_block_2(component, ctx);
          if_block1.c();
          if_block1.m(header, text1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }

      if (ctx._showHome) {
        if (if_block2) {
          if_block2.p(changed, ctx);
        } else {
          if_block2 = create_if_block_1(component, ctx);
          if_block2.c();
          if_block2.m(header, null);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }

      if (changed.style) {
        header.style.cssText = ctx.style;
      }
    },
    d: function destroy(detach) {
      if (detach) {
        Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["detachNode"])(header);
      }

      if (if_block0) if_block0.d();
      if (if_block1) if_block1.d();
      if (if_block2) if_block2.d();
    }
  };
} // (3:2) {#if _navigableRoute.routeBack || _showBack }


function create_if_block_3(component, ctx) {
  var div;
  var icon_initial_data = {
    symbol: "chevron-left",
    width: "10px",
    color: ctx.textColor
  };
  var icon = new _mamba_icon__WEBPACK_IMPORTED_MODULE_1__["default"]({
    root: component.root,
    store: component.store,
    data: icon_initial_data
  });

  function click_handler(event) {
    component._goBack();
  }

  return {
    c: function create() {
      div = Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["createElement"])("div");

      icon._fragment.c();

      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["addListener"])(div, "click", click_handler);
      div.className = "icon-left svelte-lzlsp4";
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["addLoc"])(div, file, 3, 2, 110);
    },
    m: function mount(target, anchor) {
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["insert"])(target, div, anchor);

      icon._mount(div, null);
    },
    p: function update(changed, ctx) {
      var icon_changes = {};
      if (changed.textColor) icon_changes.color = ctx.textColor;

      icon._set(icon_changes);
    },
    d: function destroy(detach) {
      if (detach) {
        Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["detachNode"])(div);
      }

      icon.destroy();
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["removeListener"])(div, "click", click_handler);
    }
  };
} // (7:8) {#if title}


function create_if_block_2(component, ctx) {
  var div, text;
  return {
    c: function create() {
      div = Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["createElement"])("div");
      text = Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["createText"])(ctx.title);
      div.className = "title svelte-lzlsp4";
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["addLoc"])(div, file, 7, 2, 254);
    },
    m: function mount(target, anchor) {
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["insert"])(target, div, anchor);
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["append"])(div, text);
    },
    p: function update(changed, ctx) {
      if (changed.title) {
        Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["setData"])(text, ctx.title);
      }
    },
    d: function destroy(detach) {
      if (detach) {
        Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["detachNode"])(div);
      }
    }
  };
} // (9:8) {#if _showHome}


function create_if_block_1(component, ctx) {
  var div;
  var icon_initial_data = {
    symbol: ctx._isAtHome ? 'home' : 'app-home',
    color: ctx.textColor
  };
  var icon = new _mamba_icon__WEBPACK_IMPORTED_MODULE_1__["default"]({
    root: component.root,
    store: component.store,
    data: icon_initial_data
  });

  function click_handler(event) {
    component._goHome();
  }

  return {
    c: function create() {
      div = Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["createElement"])("div");

      icon._fragment.c();

      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["addListener"])(div, "click", click_handler);
      div.className = "icon-right svelte-lzlsp4";
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["addLoc"])(div, file, 9, 2, 313);
    },
    m: function mount(target, anchor) {
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["insert"])(target, div, anchor);

      icon._mount(div, null);
    },
    p: function update(changed, ctx) {
      var icon_changes = {};
      if (changed._isAtHome) icon_changes.symbol = ctx._isAtHome ? 'home' : 'app-home';
      if (changed.textColor) icon_changes.color = ctx.textColor;

      icon._set(icon_changes);
    },
    d: function destroy(detach) {
      if (detach) {
        Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["detachNode"])(div);
      }

      icon.destroy();
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["removeListener"])(div, "click", click_handler);
    }
  };
}

function AppBar(options) {
  var _this2 = this;

  this._debugName = '<AppBar>';

  if (!options || !options.target && !options.root) {
    throw new Error("'target' is a required option");
  }

  Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["init"])(this, options);
  this._state = Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["assign"])(data(), options.data);

  this._recompute({
    bgColor: 1,
    textColor: 1,
    border: 1,
    _location: 1,
    _isAtHome: 1,
    _isNavigationEnabled: 1
  }, this._state);

  if (!('bgColor' in this._state)) console.warn("<AppBar> was created without expected data property 'bgColor'");
  if (!('textColor' in this._state)) console.warn("<AppBar> was created without expected data property 'textColor'");
  if (!('border' in this._state)) console.warn("<AppBar> was created without expected data property 'border'");
  if (!('_location' in this._state)) console.warn("<AppBar> was created without expected data property '_location'");
  if (!('_isNavigationEnabled' in this._state)) console.warn("<AppBar> was created without expected data property '_isNavigationEnabled'");
  if (!('_hideAppBar' in this._state)) console.warn("<AppBar> was created without expected data property '_hideAppBar'");
  if (!('_navigableRoute' in this._state)) console.warn("<AppBar> was created without expected data property '_navigableRoute'");
  if (!('title' in this._state)) console.warn("<AppBar> was created without expected data property 'title'");
  this._intro = true;
  this._handlers.state = [onstate];
  this._handlers.destroy = [ondestroy];
  onstate.call(this, {
    changed: Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["assignTrue"])({}, this._state),
    current: this._state
  });
  this._fragment = create_main_fragment(this, this._state);

  this.root._oncreate.push(function () {
    oncreate.call(_this2);

    _this2.fire("update", {
      changed: Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["assignTrue"])({}, _this2._state),
      current: _this2._state
    });
  });

  if (options.target) {
    if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");

    this._fragment.c();

    this._mount(options.target, options.anchor);

    Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["flush"])(this);
  }
}

Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["assign"])(AppBar.prototype, svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["protoDev"]);
Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["assign"])(AppBar.prototype, methods);

AppBar.prototype._checkReadOnly = function _checkReadOnly(newState) {
  if ('style' in newState && !this._updatingReadonlyProperty) throw new Error("<AppBar>: Cannot set read-only property 'style'");
  if ('_isAtHome' in newState && !this._updatingReadonlyProperty) throw new Error("<AppBar>: Cannot set read-only property '_isAtHome'");
  if ('_showBack' in newState && !this._updatingReadonlyProperty) throw new Error("<AppBar>: Cannot set read-only property '_showBack'");
  if ('_showHome' in newState && !this._updatingReadonlyProperty) throw new Error("<AppBar>: Cannot set read-only property '_showHome'");
};

AppBar.prototype._recompute = function _recompute(changed, state) {
  if (changed.bgColor || changed.textColor || changed.border) {
    if (this._differs(state.style, state.style = style(state))) changed.style = true;
  }

  if (changed._location) {
    if (this._differs(state._isAtHome, state._isAtHome = _isAtHome(state))) changed._isAtHome = true;
  }

  if (changed._isAtHome || changed._isNavigationEnabled) {
    if (this._differs(state._showBack, state._showBack = _showBack(state))) changed._showBack = true;
  }

  if (changed._isNavigationEnabled) {
    if (this._differs(state._showHome, state._showHome = _showHome(state))) changed._showHome = true;
  }
};

if (false) { var _require, configure, register, reload; }

/* harmony default export */ __webpack_exports__["default"] = (AppBar);


/***/ }),

/***/ "../node_modules/@mamba/appbar/AppBar.svelte.css":
/*!*******************************************************!*\
  !*** ../node_modules/@mamba/appbar/AppBar.svelte.css ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "../node_modules/@mamba/appbar/Modifier.html":
/*!***************************************************!*\
  !*** ../node_modules/@mamba/appbar/Modifier.html ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var core_js_modules_es_object_assign__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es.object.assign */ "../node_modules/core-js/modules/es.object.assign.js");
/* harmony import */ var core_js_modules_es_object_assign__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_assign__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var svelte_shared_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! svelte/shared.js */ "../node_modules/svelte/shared.js");


/* node_modules/@mamba/appbar/Modifier.html generated by Svelte v2.16.1 */


function onupdate(_ref) {
  var previous = _ref.previous;

  /* istanbul ignore else */
  if (!previous && this.options.data) {
    this.root.fire('appbar:modify', Object.assign({}, this.options.data));
  }
}

;
var file = "node_modules/mamba/appbar/Modifier.html";

function create_main_fragment(component, ctx) {
  return {
    c: svelte_shared_js__WEBPACK_IMPORTED_MODULE_1__["noop"],
    m: svelte_shared_js__WEBPACK_IMPORTED_MODULE_1__["noop"],
    p: svelte_shared_js__WEBPACK_IMPORTED_MODULE_1__["noop"],
    d: svelte_shared_js__WEBPACK_IMPORTED_MODULE_1__["noop"]
  };
}

function Modifier(options) {
  var _this = this;

  this._debugName = '<Modifier>';

  if (!options || !options.target && !options.root) {
    throw new Error("'target' is a required option");
  }

  Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_1__["init"])(this, options);
  this._state = Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_1__["assign"])({}, options.data);
  this._intro = true;
  this._handlers.update = [onupdate];
  this._fragment = create_main_fragment(this, this._state);

  this.root._oncreate.push(function () {
    _this.fire("update", {
      changed: Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_1__["assignTrue"])({}, _this._state),
      current: _this._state
    });
  });

  if (options.target) {
    if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");

    this._fragment.c();

    this._mount(options.target, options.anchor);

    Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_1__["flush"])(this);
  }
}

Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_1__["assign"])(Modifier.prototype, svelte_shared_js__WEBPACK_IMPORTED_MODULE_1__["protoDev"]);

Modifier.prototype._checkReadOnly = function _checkReadOnly(newState) {};

if (false) { var _require, configure, register, reload; }

/* harmony default export */ __webpack_exports__["default"] = (Modifier);

/***/ }),

/***/ "../node_modules/@mamba/button/Button.html":
/*!*************************************************!*\
  !*** ../node_modules/@mamba/button/Button.html ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/shared.js */ "../node_modules/svelte/shared.js");
/* harmony import */ var _mnt_c_Users_frodrigues_projects_mambandroid_poc_node_modules_mamba_button_Button_svelte_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node_modules/@mamba/button/Button.svelte.css */ "../node_modules/@mamba/button/Button.svelte.css");
/* harmony import */ var _mnt_c_Users_frodrigues_projects_mambandroid_poc_node_modules_mamba_button_Button_svelte_css__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_mnt_c_Users_frodrigues_projects_mambandroid_poc_node_modules_mamba_button_Button_svelte_css__WEBPACK_IMPORTED_MODULE_1__);
/* node_modules/@mamba/button/Button.html generated by Svelte v2.16.1 */


function style(_ref) {
  var secondary = _ref.secondary,
      bgColor = _ref.bgColor,
      textColor = _ref.textColor,
      width = _ref.width;
  var style = [];

  if (textColor) {
    style.push("color:" + textColor);
  }

  if (bgColor) {
    style.push("border-color:" + bgColor);

    if (!secondary) {
      style.push("background-color:" + bgColor);
    } else if (!textColor) {
      style.push("color:" + bgColor);
    }
  }

  if (width) {
    style.push("width:" + width);
  }

  return style.join(';');
}

;

function data() {
  return {
    /** Button size: small | normal | fill | full */
    size: 'normal',

    /** Disable the button */
    disabled: false,
    secondary: false,

    /** Make the button fixed at the bottom of the screen */
    bottom: false,

    /** Style */
    bgColor: undefined,
    textColor: undefined,
    width: undefined
  };
}

;
var methods = {
  click: function click() {
    this.refs.button.click();
  },
  focus: function focus() {
    this.refs.button.focus();
  }
};

function oncreate() {
  if (this.options.data) {
    var shortcut = this.options.data.shortcut;

    if (typeof shortcut !== 'undefined') {
      this.refs.button.setAttribute('shortcut', shortcut);
    }
  }
}

;
var file = "node_modules/mamba/button/Button.html";

function create_main_fragment(component, ctx) {
  var button,
      slot_content_default = component._slotted["default"],
      button_class_value;

  function click_handler(event) {
    component.fire("click", event);
  }

  return {
    c: function create() {
      button = Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["createElement"])("button");
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["addListener"])(button, "click", click_handler);
      button.className = button_class_value = "button size-" + ctx.size + " svelte-xzn3hg";
      button.style.cssText = ctx.style;
      button.disabled = ctx.disabled;
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["toggleClass"])(button, "at-bottom", ctx.bottom);
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["toggleClass"])(button, "is-secondary", ctx.secondary);
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["addLoc"])(button, file, 0, 0, 0);
    },
    m: function mount(target, anchor) {
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["insert"])(target, button, anchor);

      if (slot_content_default) {
        Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["append"])(button, slot_content_default);
      }

      component.refs.button = button;
    },
    p: function update(changed, ctx) {
      if (changed.size && button_class_value !== (button_class_value = "button size-" + ctx.size + " svelte-xzn3hg")) {
        button.className = button_class_value;
      }

      if (changed.style) {
        button.style.cssText = ctx.style;
      }

      if (changed.disabled) {
        button.disabled = ctx.disabled;
      }

      if (changed.size || changed.bottom) {
        Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["toggleClass"])(button, "at-bottom", ctx.bottom);
      }

      if (changed.size || changed.secondary) {
        Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["toggleClass"])(button, "is-secondary", ctx.secondary);
      }
    },
    d: function destroy(detach) {
      if (detach) {
        Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["detachNode"])(button);
      }

      if (slot_content_default) {
        Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["reinsertChildren"])(button, slot_content_default);
      }

      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["removeListener"])(button, "click", click_handler);
      if (component.refs.button === button) component.refs.button = null;
    }
  };
}

function Button(options) {
  var _this = this;

  this._debugName = '<Button>';

  if (!options || !options.target && !options.root) {
    throw new Error("'target' is a required option");
  }

  Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["init"])(this, options);
  this.refs = {};
  this._state = Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["assign"])(data(), options.data);

  this._recompute({
    secondary: 1,
    bgColor: 1,
    textColor: 1,
    width: 1
  }, this._state);

  if (!('secondary' in this._state)) console.warn("<Button> was created without expected data property 'secondary'");
  if (!('bgColor' in this._state)) console.warn("<Button> was created without expected data property 'bgColor'");
  if (!('textColor' in this._state)) console.warn("<Button> was created without expected data property 'textColor'");
  if (!('width' in this._state)) console.warn("<Button> was created without expected data property 'width'");
  if (!('size' in this._state)) console.warn("<Button> was created without expected data property 'size'");
  if (!('bottom' in this._state)) console.warn("<Button> was created without expected data property 'bottom'");
  if (!('disabled' in this._state)) console.warn("<Button> was created without expected data property 'disabled'");
  this._intro = true;
  this._slotted = options.slots || {};
  this._fragment = create_main_fragment(this, this._state);

  this.root._oncreate.push(function () {
    oncreate.call(_this);

    _this.fire("update", {
      changed: Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["assignTrue"])({}, _this._state),
      current: _this._state
    });
  });

  if (options.target) {
    if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");

    this._fragment.c();

    this._mount(options.target, options.anchor);

    Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["flush"])(this);
  }
}

Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["assign"])(Button.prototype, svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["protoDev"]);
Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["assign"])(Button.prototype, methods);

Button.prototype._checkReadOnly = function _checkReadOnly(newState) {
  if ('style' in newState && !this._updatingReadonlyProperty) throw new Error("<Button>: Cannot set read-only property 'style'");
};

Button.prototype._recompute = function _recompute(changed, state) {
  if (changed.secondary || changed.bgColor || changed.textColor || changed.width) {
    if (this._differs(state.style, state.style = style(state))) changed.style = true;
  }
};

if (false) { var _require, configure, register, reload; }

/* harmony default export */ __webpack_exports__["default"] = (Button);


/***/ }),

/***/ "../node_modules/@mamba/button/Button.svelte.css":
/*!*******************************************************!*\
  !*** ../node_modules/@mamba/button/Button.svelte.css ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "../node_modules/@mamba/dialog/Dialog.html":
/*!*************************************************!*\
  !*** ../node_modules/@mamba/dialog/Dialog.html ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var core_js_modules_es_parse_float__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es.parse-float */ "../node_modules/core-js/modules/es.parse-float.js");
/* harmony import */ var core_js_modules_es_parse_float__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_parse_float__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es_promise__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! core-js/modules/es.promise */ "../node_modules/core-js/modules/es.promise.js");
/* harmony import */ var core_js_modules_es_promise__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_promise__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! svelte/shared.js */ "../node_modules/svelte/shared.js");
/* harmony import */ var _mnt_c_Users_frodrigues_projects_mambandroid_poc_node_modules_mamba_dialog_Dialog_svelte_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../node_modules/@mamba/dialog/Dialog.svelte.css */ "../node_modules/@mamba/dialog/Dialog.svelte.css");
/* harmony import */ var _mnt_c_Users_frodrigues_projects_mambandroid_poc_node_modules_mamba_dialog_Dialog_svelte_css__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_mnt_c_Users_frodrigues_projects_mambandroid_poc_node_modules_mamba_dialog_Dialog_svelte_css__WEBPACK_IMPORTED_MODULE_3__);



/* node_modules/@mamba/dialog/Dialog.html generated by Svelte v2.16.1 */

/** Static variables */

/** Number of dialogs currently opened */

var dialogsOpened = 0;
/** Previous navigable (app meta) object */

var previousNavigable = null;
var lastShortcutsState = undefined;

function style(_ref) {
  var bgColor = _ref.bgColor,
      textColor = _ref.textColor;
  return ["background-color:" + bgColor, "color:" + textColor].filter(Boolean).join(';');
}

;

function _class(_ref2) {
  var className = _ref2.className;
  return className ? " " + className : '';
}

;

function data() {
  return {
    /** Dialog open state */
    isOpen: false,
    title: undefined,
    bgColor: '#e3e3e3',
    textColor: '#353535',
    align: 'center',
    fullscreen: false,
    className: undefined
  };
}

;
var methods = {
  open: function open(duration) {
    this.set({
      isOpen: true
    });

    if (typeof duration !== 'undefined') {
      return this.close(duration);
    }

    return Promise.resolve();
  },
  close: function close(delay) {
    var _this = this;

    if (typeof delay !== 'undefined') {
      return new Promise(function (resolve) {
        return setTimeout(function () {
          _this.close();

          resolve();
        }, parseFloat(delay));
      });
    }

    this.set({
      isOpen: false
    });
    return Promise.resolve();
  },

  /** Private close method. Used on .close() and ondestroy() */
  _close: function _close() {
    /** Allow app to scroll again */

    /* istanbul ignore else */
    if (dialogsOpened === 1 && this.root.meta && previousNavigable != null) {
      /** Let's unlock the app */
      this.root.meta.set({
        navigable: previousNavigable,
        scrollable: true
      });
      previousNavigable = null;
    }
  }
};

function ondestroy() {
  /** If the component is being destroyed and the dialog is still opened, let's unlock the app */
  if (this.get().isOpen) {
    this._close();
  }
}

;

function onupdate(_ref3) {
  var changed = _ref3.changed,
      current = _ref3.current,
      previous = _ref3.previous;

  /* istanbul ignore next */
  if (changed.isOpen) {
    var isOpen = current.isOpen;
    var _dialog = this.refs._dialog;

    if (this.root.meta) {
      if (isOpen) {
        lastShortcutsState = this.root.meta.get().shortcuts;
        this.root.meta.setShortcuts(true);
      } else if (lastShortcutsState != undefined) {
        this.root.meta.setShortcuts(lastShortcutsState);
      }
    }

    if (isOpen) {
      dialogsOpened++;
      this.fire('open');
      /**
       * Unfocus whatever is focused on the current page.
       * ! This may not work properly if a <Input/> has forcefocus={true}
       */

      document.activeElement.blur(); // Force a div focus with tabindex="-1" to prevent Keystroke actions in App.html method checker

      if (_dialog) _dialog.focus();

      if (dialogsOpened === 1 && this.root.meta) {
        var _this$root$meta$get = this.root.meta.get(),
            scrollable = _this$root$meta$get.scrollable,
            navigable = _this$root$meta$get.navigable;
        /** Disable app scroll when opening a dialog */

        /* istanbul ignore else */


        if (scrollable) {
          this.root.meta.set({
            scrollable: false
          });
        }

        previousNavigable = navigable;
        this.root.meta.setNavigable(false);
      }
    } else if (previous) {
      if (_dialog) _dialog.blur();

      this._close();

      dialogsOpened--;
      this.fire('close');
    }
  }
}

;
var file = "node_modules/mamba/dialog/Dialog.html";

function create_main_fragment(component, ctx) {
  var if_block_anchor;
  var if_block = ctx.isOpen && create_if_block(component, ctx);
  return {
    c: function create() {
      if (if_block) if_block.c();
      if_block_anchor = Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["createComment"])();
    },
    m: function mount(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["insert"])(target, if_block_anchor, anchor);
    },
    p: function update(changed, ctx) {
      if (ctx.isOpen) {
        if (if_block) {
          if_block.p(changed, ctx);
        } else {
          if_block = create_if_block(component, ctx);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d: function destroy(detach) {
      if (if_block) if_block.d(detach);

      if (detach) {
        Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["detachNode"])(if_block_anchor);
      }
    }
  };
} // (1:0) {#if isOpen}


function create_if_block(component, ctx) {
  var div3,
      div2,
      div0,
      text0,
      slot_content_default = component._slotted["default"],
      slot_content_default_before,
      text1,
      div1,
      slot_content_extra = component._slotted.extra,
      div2_class_value,
      div3_class_value;
  var if_block = ctx.title && create_if_block_1(component, ctx);

  function keyup_handler(event) {
    component.fire("keyup", event);
  }

  return {
    c: function create() {
      div3 = Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["createElement"])("div");
      div2 = Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["createElement"])("div");
      div0 = Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["createElement"])("div");
      if (if_block) if_block.c();
      text0 = Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["createText"])("\n        ");
      text1 = Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["createText"])("\n      ");
      div1 = Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["createElement"])("div");
      div0.className = "message svelte-hbjm2q";
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["addLoc"])(div0, file, 11, 6, 228);
      div1.className = "extra";
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["addLoc"])(div1, file, 17, 6, 368);
      div2.className = div2_class_value = "content -align-" + ctx.align + " svelte-hbjm2q";
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["addLoc"])(div2, file, 10, 4, 185);
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["addListener"])(div3, "keyup", keyup_handler);
      div3.className = div3_class_value = "dialog" + ctx._class + " svelte-hbjm2q";
      div3.style.cssText = ctx.style;
      div3.tabIndex = "-1";
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["setAttribute"])(div3, "data-freeze-keystrokes", "true");
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["toggleClass"])(div3, "is-fullscreen", ctx.fullscreen);
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["addLoc"])(div3, file, 1, 2, 15);
    },
    m: function mount(target, anchor) {
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["insert"])(target, div3, anchor);
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["append"])(div3, div2);
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["append"])(div2, div0);
      if (if_block) if_block.m(div0, null);
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["append"])(div0, text0);

      if (slot_content_default) {
        Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["append"])(div0, slot_content_default_before || (slot_content_default_before = Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["createComment"])()));
        Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["append"])(div0, slot_content_default);
      }

      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["append"])(div2, text1);
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["append"])(div2, div1);

      if (slot_content_extra) {
        Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["append"])(div1, slot_content_extra);
      }

      component.refs._dialog = div3;
    },
    p: function update(changed, ctx) {
      if (ctx.title) {
        if (if_block) {
          if_block.p(changed, ctx);
        } else {
          if_block = create_if_block_1(component, ctx);
          if_block.c();
          if_block.m(div0, text0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }

      if (changed.align && div2_class_value !== (div2_class_value = "content -align-" + ctx.align + " svelte-hbjm2q")) {
        div2.className = div2_class_value;
      }

      if (changed._class && div3_class_value !== (div3_class_value = "dialog" + ctx._class + " svelte-hbjm2q")) {
        div3.className = div3_class_value;
      }

      if (changed.style) {
        div3.style.cssText = ctx.style;
      }

      if (changed._class || changed.fullscreen) {
        Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["toggleClass"])(div3, "is-fullscreen", ctx.fullscreen);
      }
    },
    d: function destroy(detach) {
      if (detach) {
        Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["detachNode"])(div3);
      }

      if (if_block) if_block.d();

      if (slot_content_default) {
        Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["reinsertAfter"])(slot_content_default_before, slot_content_default);
      }

      if (slot_content_extra) {
        Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["reinsertChildren"])(div1, slot_content_extra);
      }

      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["removeListener"])(div3, "keyup", keyup_handler);
      if (component.refs._dialog === div3) component.refs._dialog = null;
    }
  };
} // (13:8) {#if title}


function create_if_block_1(component, ctx) {
  var div, text;
  return {
    c: function create() {
      div = Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["createElement"])("div");
      text = Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["createText"])(ctx.title);
      div.className = "title svelte-hbjm2q";
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["addLoc"])(div, file, 13, 10, 280);
    },
    m: function mount(target, anchor) {
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["insert"])(target, div, anchor);
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["append"])(div, text);
    },
    p: function update(changed, ctx) {
      if (changed.title) {
        Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["setData"])(text, ctx.title);
      }
    },
    d: function destroy(detach) {
      if (detach) {
        Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["detachNode"])(div);
      }
    }
  };
}

function Dialog(options) {
  var _this2 = this;

  this._debugName = '<Dialog>';

  if (!options || !options.target && !options.root) {
    throw new Error("'target' is a required option");
  }

  Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["init"])(this, options);
  this.refs = {};
  this._state = Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["assign"])(data(), options.data);

  this._recompute({
    bgColor: 1,
    textColor: 1,
    className: 1
  }, this._state);

  if (!('bgColor' in this._state)) console.warn("<Dialog> was created without expected data property 'bgColor'");
  if (!('textColor' in this._state)) console.warn("<Dialog> was created without expected data property 'textColor'");
  if (!('className' in this._state)) console.warn("<Dialog> was created without expected data property 'className'");
  if (!('isOpen' in this._state)) console.warn("<Dialog> was created without expected data property 'isOpen'");
  if (!('fullscreen' in this._state)) console.warn("<Dialog> was created without expected data property 'fullscreen'");
  if (!('align' in this._state)) console.warn("<Dialog> was created without expected data property 'align'");
  if (!('title' in this._state)) console.warn("<Dialog> was created without expected data property 'title'");
  this._intro = true;
  this._handlers.update = [onupdate];
  this._handlers.destroy = [ondestroy];
  this._slotted = options.slots || {};
  this._fragment = create_main_fragment(this, this._state);

  this.root._oncreate.push(function () {
    _this2.fire("update", {
      changed: Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["assignTrue"])({}, _this2._state),
      current: _this2._state
    });
  });

  if (options.target) {
    if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");

    this._fragment.c();

    this._mount(options.target, options.anchor);

    Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["flush"])(this);
  }
}

Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["assign"])(Dialog.prototype, svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["protoDev"]);
Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["assign"])(Dialog.prototype, methods);

Dialog.prototype._checkReadOnly = function _checkReadOnly(newState) {
  if ('style' in newState && !this._updatingReadonlyProperty) throw new Error("<Dialog>: Cannot set read-only property 'style'");
  if ('_class' in newState && !this._updatingReadonlyProperty) throw new Error("<Dialog>: Cannot set read-only property '_class'");
};

Dialog.prototype._recompute = function _recompute(changed, state) {
  if (changed.bgColor || changed.textColor) {
    if (this._differs(state.style, state.style = style(state))) changed.style = true;
  }

  if (changed.className) {
    if (this._differs(state._class, state._class = _class(state))) changed._class = true;
  }
};

if (false) { var _require, configure, register, reload; }

/* harmony default export */ __webpack_exports__["default"] = (Dialog);


/***/ }),

/***/ "../node_modules/@mamba/dialog/Dialog.svelte.css":
/*!*******************************************************!*\
  !*** ../node_modules/@mamba/dialog/Dialog.svelte.css ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "../node_modules/@mamba/icon/Icon.html":
/*!*********************************************!*\
  !*** ../node_modules/@mamba/icon/Icon.html ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/shared.js */ "../node_modules/svelte/shared.js");
/* harmony import */ var _mnt_c_Users_frodrigues_projects_mambandroid_poc_node_modules_mamba_icon_Icon_svelte_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node_modules/@mamba/icon/Icon.svelte.css */ "../node_modules/@mamba/icon/Icon.svelte.css");
/* harmony import */ var _mnt_c_Users_frodrigues_projects_mambandroid_poc_node_modules_mamba_icon_Icon_svelte_css__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_mnt_c_Users_frodrigues_projects_mambandroid_poc_node_modules_mamba_icon_Icon_svelte_css__WEBPACK_IMPORTED_MODULE_1__);
/* node_modules/@mamba/icon/Icon.html generated by Svelte v2.16.1 */


function iconStyle(_ref) {
  var src = _ref.src,
      color = _ref.color,
      width = _ref.width,
      height = _ref.height;
  return [color && "color:" + color,
  /* istanbul ignore next */
  src && "-webkit-mask-image: url(" + src + ")", width && "width: " + width, height && "height: " + height].filter(Boolean).join(';');
}

function data() {
  return {
    size: 'normal',
    symbol: 'custom',
    src: undefined,
    color: undefined,
    width: undefined,
    height: undefined,
    level: undefined
  };
}

;
var file = "node_modules/mamba/icon/Icon.html";

function create_main_fragment(component, ctx) {
  var div;

  function click_handler(event) {
    component.fire("click", event);
  }

  return {
    c: function create() {
      div = Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["createElement"])("div");
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["addListener"])(div, "click", click_handler);
      div.className = "icon svelte-105ukiy";
      div.style.cssText = ctx.iconStyle;
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["setAttribute"])(div, "symbol", ctx.symbol);
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["setAttribute"])(div, "size", ctx.size);
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["setAttribute"])(div, "level", ctx.level);
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["addLoc"])(div, file, 0, 0, 0);
    },
    m: function mount(target, anchor) {
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["insert"])(target, div, anchor);
      component.refs.icon = div;
    },
    p: function update(changed, ctx) {
      if (changed.iconStyle) {
        div.style.cssText = ctx.iconStyle;
      }

      if (changed.symbol) {
        Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["setAttribute"])(div, "symbol", ctx.symbol);
      }

      if (changed.size) {
        Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["setAttribute"])(div, "size", ctx.size);
      }

      if (changed.level) {
        Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["setAttribute"])(div, "level", ctx.level);
      }
    },
    d: function destroy(detach) {
      if (detach) {
        Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["detachNode"])(div);
      }

      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["removeListener"])(div, "click", click_handler);
      if (component.refs.icon === div) component.refs.icon = null;
    }
  };
}

function Icon(options) {
  this._debugName = '<Icon>';

  if (!options || !options.target && !options.root) {
    throw new Error("'target' is a required option");
  }

  Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["init"])(this, options);
  this.refs = {};
  this._state = Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["assign"])(data(), options.data);

  this._recompute({
    src: 1,
    color: 1,
    width: 1,
    height: 1
  }, this._state);

  if (!('src' in this._state)) console.warn("<Icon> was created without expected data property 'src'");
  if (!('color' in this._state)) console.warn("<Icon> was created without expected data property 'color'");
  if (!('width' in this._state)) console.warn("<Icon> was created without expected data property 'width'");
  if (!('height' in this._state)) console.warn("<Icon> was created without expected data property 'height'");
  if (!('symbol' in this._state)) console.warn("<Icon> was created without expected data property 'symbol'");
  if (!('size' in this._state)) console.warn("<Icon> was created without expected data property 'size'");
  if (!('level' in this._state)) console.warn("<Icon> was created without expected data property 'level'");
  this._intro = true;
  this._fragment = create_main_fragment(this, this._state);

  if (options.target) {
    if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");

    this._fragment.c();

    this._mount(options.target, options.anchor);
  }
}

Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["assign"])(Icon.prototype, svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["protoDev"]);

Icon.prototype._checkReadOnly = function _checkReadOnly(newState) {
  if ('iconStyle' in newState && !this._updatingReadonlyProperty) throw new Error("<Icon>: Cannot set read-only property 'iconStyle'");
};

Icon.prototype._recompute = function _recompute(changed, state) {
  if (changed.src || changed.color || changed.width || changed.height) {
    if (this._differs(state.iconStyle, state.iconStyle = iconStyle(state))) changed.iconStyle = true;
  }
};

if (false) { var _require, configure, register, reload; }

/* harmony default export */ __webpack_exports__["default"] = (Icon);


/***/ }),

/***/ "../node_modules/@mamba/icon/Icon.svelte.css":
/*!***************************************************!*\
  !*** ../node_modules/@mamba/icon/Icon.svelte.css ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "../node_modules/@mamba/pos/api/app.js":
/*!*********************************************!*\
  !*** ../node_modules/@mamba/pos/api/app.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _drivers_extend_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../drivers/extend.js */ "../node_modules/@mamba/pos/drivers/extend.js");
/* harmony import */ var _drivers_app_wrappers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../drivers/app/wrappers.js */ "../node_modules/@mamba/pos/drivers/app/wrappers.js");


/* harmony default export */ __webpack_exports__["default"] = (Object(_drivers_extend_js__WEBPACK_IMPORTED_MODULE_0__["default"])(window.$App, _drivers_app_wrappers_js__WEBPACK_IMPORTED_MODULE_1__["default"]));

/***/ }),

/***/ "../node_modules/@mamba/pos/api/keyboard.js":
/*!**************************************************!*\
  !*** ../node_modules/@mamba/pos/api/keyboard.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _drivers_extend_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../drivers/extend.js */ "../node_modules/@mamba/pos/drivers/extend.js");
/* harmony import */ var _drivers_keyboard_wrappers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../drivers/keyboard/wrappers.js */ "../node_modules/@mamba/pos/drivers/keyboard/wrappers.js");


/* harmony default export */ __webpack_exports__["default"] = (Object(_drivers_extend_js__WEBPACK_IMPORTED_MODULE_0__["default"])(window.$Keyboard, _drivers_keyboard_wrappers_js__WEBPACK_IMPORTED_MODULE_1__["default"]));

/***/ }),

/***/ "../node_modules/@mamba/pos/api/merchant.js":
/*!**************************************************!*\
  !*** ../node_modules/@mamba/pos/api/merchant.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _drivers_extend_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../drivers/extend.js */ "../node_modules/@mamba/pos/drivers/extend.js");

/* harmony default export */ __webpack_exports__["default"] = (Object(_drivers_extend_js__WEBPACK_IMPORTED_MODULE_0__["default"])(window.$Merchant));

/***/ }),

/***/ "../node_modules/@mamba/pos/api/printer.js":
/*!*************************************************!*\
  !*** ../node_modules/@mamba/pos/api/printer.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _drivers_extend_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../drivers/extend.js */ "../node_modules/@mamba/pos/drivers/extend.js");
/* harmony import */ var _drivers_printer_wrappers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../drivers/printer/wrappers.js */ "../node_modules/@mamba/pos/drivers/printer/wrappers.js");


/* harmony default export */ __webpack_exports__["default"] = (Object(_drivers_extend_js__WEBPACK_IMPORTED_MODULE_0__["default"])(window.$Printer, _drivers_printer_wrappers_js__WEBPACK_IMPORTED_MODULE_1__["default"]));

/***/ }),

/***/ "../node_modules/@mamba/pos/drivers/app/wrappers.js":
/*!**********************************************************!*\
  !*** ../node_modules/@mamba/pos/drivers/app/wrappers.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (driver) {
  driver.close = driver.doClose;
});

/***/ }),

/***/ "../node_modules/@mamba/pos/drivers/base.js":
/*!**************************************************!*\
  !*** ../node_modules/@mamba/pos/drivers/base.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var core_js_modules_es_array_find_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es.array.find-index */ "../node_modules/core-js/modules/es.array.find-index.js");
/* harmony import */ var core_js_modules_es_array_find_index__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_find_index__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_web_dom_collections_for_each__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! core-js/modules/web.dom-collections.for-each */ "../node_modules/core-js/modules/web.dom-collections.for-each.js");
/* harmony import */ var core_js_modules_web_dom_collections_for_each__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_web_dom_collections_for_each__WEBPACK_IMPORTED_MODULE_1__);


var DEFAULT_GROUP_NAME = 'default';
/* harmony default export */ __webpack_exports__["default"] = (function () {
  var defaultGroup = {};
  var groups = {
    "default": defaultGroup
  };
  var currentGroupName = DEFAULT_GROUP_NAME;
  var currentGroup = defaultGroup;

  var isSlotFilled = function isSlotFilled(signal, callback) {
    var callbackList = currentGroup[signal];
    return callbackList && callbackList.length && callbackList.indexOf(callback) > -1;
  };

  return {
    getGroups: function getGroups() {
      return groups;
    },
    group: function group(groupName) {
      currentGroupName = groupName;

      if (groups[groupName]) {
        currentGroup = groups[groupName];
      } else {
        currentGroup = {};
        groups[groupName] = currentGroup;
      }

      return this;
    },
    endGroup: function endGroup() {
      currentGroup = defaultGroup;
      currentGroupName = DEFAULT_GROUP_NAME;
      return this;
    },
    fire: function fire(signal) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      this[signal].apply(this, args);
    },

    /** Connect a callback to a slot */
    on: function on(signal, callback) {
      if (typeof callback === 'function') {
        if (!currentGroup[signal]) {
          currentGroup[signal] = [];
        }

        currentGroup[signal].push(callback);
        this[signal].connect(callback);
      }

      return this;
    },

    /** Disconnect a callback from a slot */
    off: function off(signal, callback) {
      var group = currentGroup;
      /** If no callback passed, disconnect all slots from the signal */

      if (typeof callback === 'undefined') {
        for (var i = group[signal].length; i--;) {
          this[signal].disconnect(group[signal][i]);
        }

        delete group[signal];
      } else {
        var slotIndex = group[signal].findIndex(function (slotCallback) {
          return slotCallback === callback;
        });

        if (slotIndex > -1) {
          this[signal].disconnect(group[signal][slotIndex]);
          group[signal].splice(slotIndex, 1);
          /** Delete the signal slot list if it's empty */

          if (group[signal].length === 0) {
            delete group[signal];
          }
        } else if (true) {
          console.warn("[@mamba/pos/driver] Tried to disconnect from \"" + signal + "\" a non-connected slot (group: " + currentGroupName + ").");
        }
      }
      /** If the current signal group is empty, let's delete it */


      if (currentGroup !== defaultGroup && Object.keys(group).length === 0) {
        delete groups[currentGroupName];
        this.endGroup();
      }

      return this;
    },

    /** Allow only a unique callback on a specific slot */
    unique: function unique(signal, callback) {
      if (isSlotFilled(signal, callback)) {
        this.off(signal, callback);
      }

      return this.on(signal, callback);
    },

    /** Execute once a callback when the signal is dispatched and disconnect from it */
    once: function once(signal, callback) {
      return this.race([[signal, callback]]);
    },

    /** The first signal dispatched is executed and automatically cancel all others */
    race: function race(entries) {
      var _this = this;

      var wrappedCallbacks = {};
      entries.forEach(function (_ref) {
        var signal = _ref[0],
            callback = _ref[1];

        if (false === 2) {
          console.log("Connecting once '" + signal + "'");
        }
        /** If the signal's slot is already filled with a callback, disconnect it */


        if (isSlotFilled(signal, callback)) {
          _this.off(signal, callback);
        }
        /**
         * Wrap the signal callback to disconnect all slots once one of the signals are emitted
         * If the return of a callback is "false", it doesn't unlisten automatically
         */


        wrappedCallbacks[signal] = function () {
          var result = callback.apply(void 0, arguments);

          if (result !== false) {
            Object.keys(wrappedCallbacks).forEach(function (signalName) {
              if (false === 2) {
                console.log("Removing '" + signalName + "'");
              }

              _this.off(signalName, wrappedCallbacks[signalName]);
            });
          }
        };
        /** Listen to the signal emission */


        _this.on(signal, wrappedCallbacks[signal]);
      });
      return this;
    },

    /** Destroy all signal listeners from a specified group */
    destroyGroup: function destroyGroup(groupName) {
      var _this2 = this;

      if (groupName === void 0) {
        groupName = 'default';
      }

      if (!groups[groupName]) {
        console.error("[@mamba/pos/driver] Trying to destroy non existing group: '" + groupName + "'");
        return;
      }

      this.group(groupName);
      var groupSignals = Object.keys(groups[groupName]);

      if (true) {
        console.log("Destroying signal group: \"" + groupName + "\".\nDisconnecting slots from: \"" + groupSignals.join('", "') + "\"");
      }

      groupSignals.forEach(function (signal) {
        return _this2.off(signal);
      });
      this.endGroup();
    },

    /** Destroy all signal listeners from all groups */
    destroy: function destroy() {
      var _this3 = this;

      Object.keys(groups).forEach(function (group) {
        return _this3.destroyGroup(group);
      });
    }
  };
});

/***/ }),

/***/ "../node_modules/@mamba/pos/drivers/extend.js":
/*!****************************************************!*\
  !*** ../node_modules/@mamba/pos/drivers/extend.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ "../node_modules/@mamba/pos/drivers/base.js");
/* harmony import */ var _extend_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../extend.js */ "../node_modules/@mamba/pos/extend.js");


/** Used to extend a driver with the base driver */

/* harmony default export */ __webpack_exports__["default"] = (function (driver) {
  if ( true && typeof driver === 'undefined') {
    throw new Error('[@mamba/pos] Could not find the loaded driver.');
  }

  for (var _len = arguments.length, modifiers = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    modifiers[_key - 1] = arguments[_key];
  }

  return _extend_js__WEBPACK_IMPORTED_MODULE_1__["default"].apply(void 0, [driver].concat(modifiers, [Object(_base_js__WEBPACK_IMPORTED_MODULE_0__["default"])()]));
});

/***/ }),

/***/ "../node_modules/@mamba/pos/drivers/keyboard/wrappers.js":
/*!***************************************************************!*\
  !*** ../node_modules/@mamba/pos/drivers/keyboard/wrappers.js ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var core_js_modules_es_array_find__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es.array.find */ "../node_modules/core-js/modules/es.array.find.js");
/* harmony import */ var core_js_modules_es_array_find__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_find__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es_number_constructor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! core-js/modules/es.number.constructor */ "../node_modules/core-js/modules/es.number.constructor.js");
/* harmony import */ var core_js_modules_es_number_constructor__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_number_constructor__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var core_js_modules_es_number_is_nan__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! core-js/modules/es.number.is-nan */ "../node_modules/core-js/modules/es.number.is-nan.js");
/* harmony import */ var core_js_modules_es_number_is_nan__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_number_is_nan__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var core_js_modules_es_number_parse_int__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! core-js/modules/es.number.parse-int */ "../node_modules/core-js/modules/es.number.parse-int.js");
/* harmony import */ var core_js_modules_es_number_parse_int__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_number_parse_int__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var core_js_modules_es_parse_float__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! core-js/modules/es.parse-float */ "../node_modules/core-js/modules/es.parse-float.js");
/* harmony import */ var core_js_modules_es_parse_float__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_parse_float__WEBPACK_IMPORTED_MODULE_4__);






/**
 * KeyCode <-> KeyName dictionary
 */
var KEYMAP = Object.freeze({
  13: 'enter',
  8: 'back',
  27: 'close',
  17: 'help',
  16: 'shortcuts',
  48: '0',
  49: '1',
  50: '2',
  51: '3',
  52: '4',
  53: '5',
  54: '6',
  55: '7',
  56: '8',
  57: '9'
});
/* harmony default export */ __webpack_exports__["default"] = (function (driver) {
  /**
   * Get the key code relative to a specific key name
   * @memberof Keyboard
   * @param {string} keyName - Key name
   * @returns {number} - Relative key code
   */
  driver.getKeyCode = function (keyName) {
    var keyCode = Object.keys(KEYMAP).find(function (code) {
      return KEYMAP[code] === keyName;
    });
    return keyCode ? Number.parseInt(keyCode, 10) : null;
  };
  /**
   * Get the key name relative to a specific key code
   * @memberof Keyboard
   * @param {number} keyCode - Key code
   * @returns {string} - Relative key name
   */


  driver.getKeyName = function (keyCode) {
    return KEYMAP[keyCode];
  };
  /**
   * Check if a certain key is a numeric key
   * @memberof Keyboard
   * @param {number} keyCode - Key code
   * @returns {boolean}
   */


  driver.isNumericKey = function (keyCode) {
    return !Number.isNaN(parseFloat(KEYMAP[keyCode]));
  };
  /**
   * Check if a certain key is an action key
   * @memberof Keyboard
   * @param {number} keyCode - Key code
   * @returns {boolean}
   */


  driver.isActionKey = function (keyCode) {
    return !driver.isNumericKey(keyCode);
  };
  /**
   * Define if backspace button should be enabled
   */


  var _isBackspaceEnabled = true;
  /**
   * Return if the backspace button is enabled
   * @memberof Keyboard
   * @returns {boolean}
   */

  driver.isBackspaceEnabled = function () {
    return _isBackspaceEnabled;
  };
  /**
   * Switch OFF the `isBackspaceEnabled` flag used by the front-end
   * @memberof Keyboard
   */


  driver.disableBackspace = function () {
    _isBackspaceEnabled = false;
  };
  /**
   * Switch ON the `isBackspaceEnabled` flag used by the front-end
   * @memberof Keyboard
   */


  driver.enableBackspace = function () {
    _isBackspaceEnabled = true;
  };
});

/***/ }),

/***/ "../node_modules/@mamba/pos/drivers/printer/wrappers.js":
/*!**************************************************************!*\
  !*** ../node_modules/@mamba/pos/drivers/printer/wrappers.js ***!
  \**************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var core_js_modules_es_promise__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es.promise */ "../node_modules/core-js/modules/es.promise.js");
/* harmony import */ var core_js_modules_es_promise__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_promise__WEBPACK_IMPORTED_MODULE_0__);

/* harmony default export */ __webpack_exports__["default"] = (function (driver) {
  driver.print = function (content, options) {
    if (options === void 0) {
      options = {};
    }

    return new Promise(function (resolve, reject) {
      driver.once('printerDone', function () {
        if (driver.failedPrinting()) {
          reject(new Error('NO_PAPER'));
        } else {
          resolve();
        }
      });
      driver.doPrint(content, options);
    });
  };
});

/***/ }),

/***/ "../node_modules/@mamba/pos/extend.js":
/*!********************************************!*\
  !*** ../node_modules/@mamba/pos/extend.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var core_js_modules_es_object_assign__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es.object.assign */ "../node_modules/core-js/modules/es.object.assign.js");
/* harmony import */ var core_js_modules_es_object_assign__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_assign__WEBPACK_IMPORTED_MODULE_0__);


/** Used to extend a driver with the base driver */
/* harmony default export */ __webpack_exports__["default"] = (function (o) {
  for (var _len = arguments.length, modifiers = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    modifiers[_key - 1] = arguments[_key];
  }

  for (var i = modifiers.length; i--;) {
    var modifier = modifiers[i];

    if (typeof modifier === 'function') {
      modifiers[i](o);
    } else {
      Object.assign(o, modifier);
    }
  }

  return o;
});

/***/ }),

/***/ "../node_modules/@mamba/printable/Printable.html":
/*!*******************************************************!*\
  !*** ../node_modules/@mamba/printable/Printable.html ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var core_js_modules_es_object_assign__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es.object.assign */ "../node_modules/core-js/modules/es.object.assign.js");
/* harmony import */ var core_js_modules_es_object_assign__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_assign__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es_promise__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! core-js/modules/es.promise */ "../node_modules/core-js/modules/es.promise.js");
/* harmony import */ var core_js_modules_es_promise__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_promise__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! svelte/shared.js */ "../node_modules/svelte/shared.js");
/* harmony import */ var _mamba_pos_api_printer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @mamba/pos/api/printer.js */ "../node_modules/@mamba/pos/api/printer.js");
/* harmony import */ var _assets_images_icon_alert_png__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./assets/images/icon-alert.png */ "../node_modules/@mamba/printable/assets/images/icon-alert.png");
/* harmony import */ var _assets_images_icon_alert_png__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_assets_images_icon_alert_png__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _mamba_dialog__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @mamba/dialog */ "../node_modules/@mamba/dialog/Dialog.html");
/* harmony import */ var _mnt_c_Users_frodrigues_projects_mambandroid_poc_node_modules_mamba_printable_Printable_svelte_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../node_modules/@mamba/printable/Printable.svelte.css */ "../node_modules/@mamba/printable/Printable.svelte.css");
/* harmony import */ var _mnt_c_Users_frodrigues_projects_mambandroid_poc_node_modules_mamba_printable_Printable_svelte_css__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_mnt_c_Users_frodrigues_projects_mambandroid_poc_node_modules_mamba_printable_Printable_svelte_css__WEBPACK_IMPORTED_MODULE_6__);



/* node_modules/@mamba/printable/Printable.html generated by Svelte v2.16.1 */




var STATES = Object.freeze({
  IDLE: 0,
  PRINTING: 1,
  FAILURE: 2,
  SUCCESS: 3
});
/** Cache the POS paper width */

var PAPER_WIDTH = _mamba_pos_api_printer_js__WEBPACK_IMPORTED_MODULE_3__["default"].getPaperWidth() + "px";

function data() {
  return {
    _state: STATES.IDLE,
    _paperWidth: PAPER_WIDTH,
    showPrintingDialog: true,
    dithering: false,
    id: null
  };
}

;
var methods = {
  print: function print(printerOptions) {
    var _this = this;

    var _this$get = this.get(),
        dithering = _this$get.dithering,
        id = _this$get.id,
        showPrintingDialog = _this$get.showPrintingDialog;

    var contentEl = this.refs.printableContent;
    /** Default printing parameters */

    printerOptions = Object.assign({
      use_dithering: dithering,
      print_to_paper: true,
      reprint_id: id
    }, printerOptions);

    if (printerOptions.print_to_paper === false) {
      _mamba_pos_api_printer_js__WEBPACK_IMPORTED_MODULE_3__["default"].print(contentEl, printerOptions);
      /** If virtual printing (save printable img only), dispatch the finish event */

      return Promise.resolve().then(function () {
        _this.fire('finish', true);
      });
    }

    this.set({
      _state: STATES.PRINTING
    });

    if (showPrintingDialog) {
      this.refs.printingDialog.open();
    }

    _mamba_pos_api_printer_js__WEBPACK_IMPORTED_MODULE_3__["default"].print(contentEl, printerOptions).then(function () {
      return _this.set({
        _state: STATES.SUCCESS
      });
    })["catch"](function () {
      return _this.set({
        _state: STATES.FAILURE
      });
    });
    /** We return a promise that resolves ONLY when the 'finish' event is fired */

    return new Promise(function (res) {
      var listener = _this.on('finish', function (hasSucceeded) {
        listener.cancel();
        res(hasSucceeded);
      });
    });
  }
};

function onupdate(_ref) {
  var changed = _ref.changed,
      current = _ref.current;

  /* istanbul ignore next */
  if (changed._state) {
    if (current._state === STATES.FAILURE) {
      this.refs.failureDialog.open(5000); // this.fire('error');
    } else if (current._state === STATES.SUCCESS) {
      this.fire('finish', true);
    }
  }
}

;
var file = "node_modules/mamba/printable/Printable.html";

function create_main_fragment(component, ctx) {
  var div1,
      div0,
      slot_content_default = component._slotted["default"],
      text0,
      text1,
      if_block1_anchor;
  var if_block0 = ctx._state === STATES.PRINTING && ctx.showPrintingDialog && create_if_block_2(component, ctx);
  var if_block1 = ctx._state === STATES.FAILURE && create_if_block(component, ctx);
  return {
    c: function create() {
      div1 = Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["createElement"])("div");
      div0 = Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["createElement"])("div");
      text0 = Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["createText"])("\n\n");
      if (if_block0) if_block0.c();
      text1 = Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["createText"])("\n\n");
      if (if_block1) if_block1.c();
      if_block1_anchor = Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["createComment"])();
      div0.className = "content svelte-11jgqmr";
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["addLoc"])(div0, file, 1, 2, 56);
      div1.className = "printable svelte-11jgqmr";
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["setStyle"])(div1, "width", ctx._paperWidth);
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["addLoc"])(div1, file, 0, 0, 0);
    },
    m: function mount(target, anchor) {
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["insert"])(target, div1, anchor);
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["append"])(div1, div0);

      if (slot_content_default) {
        Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["append"])(div0, slot_content_default);
      }

      component.refs.printableContent = div0;
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["insert"])(target, text0, anchor);
      if (if_block0) if_block0.m(target, anchor);
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["insert"])(target, text1, anchor);
      if (if_block1) if_block1.m(target, anchor);
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["insert"])(target, if_block1_anchor, anchor);
    },
    p: function update(changed, ctx) {
      if (changed._paperWidth) {
        Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["setStyle"])(div1, "width", ctx._paperWidth);
      }

      if (ctx._state === STATES.PRINTING && ctx.showPrintingDialog) {
        if (!if_block0) {
          if_block0 = create_if_block_2(component, ctx);
          if_block0.c();
          if_block0.m(text1.parentNode, text1);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }

      if (ctx._state === STATES.FAILURE) {
        if (if_block1) {
          if_block1.p(changed, ctx);
        } else {
          if_block1 = create_if_block(component, ctx);
          if_block1.c();
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    d: function destroy(detach) {
      if (detach) {
        Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["detachNode"])(div1);
      }

      if (slot_content_default) {
        Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["reinsertChildren"])(div0, slot_content_default);
      }

      if (component.refs.printableContent === div0) component.refs.printableContent = null;

      if (detach) {
        Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["detachNode"])(text0);
      }

      if (if_block0) if_block0.d(detach);

      if (detach) {
        Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["detachNode"])(text1);
      }

      if (if_block1) if_block1.d(detach);

      if (detach) {
        Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["detachNode"])(if_block1_anchor);
      }
    }
  };
} // (7:0) {#if _state === STATES.PRINTING && showPrintingDialog}


function create_if_block_2(component, ctx) {
  var div0, text, div1;
  var dialog_initial_data = {
    bgColor: "#fff",
    fullscreen: true
  };
  var dialog = new _mamba_dialog__WEBPACK_IMPORTED_MODULE_5__["default"]({
    root: component.root,
    store: component.store,
    slots: {
      "default": Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["createFragment"])()
    },
    data: dialog_initial_data
  });
  component.refs.printingDialog = dialog;
  return {
    c: function create() {
      div0 = Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["createElement"])("div");
      text = Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["createText"])("\n    ");
      div1 = Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["createElement"])("div");
      div1.textContent = "Imprimindo";

      dialog._fragment.c();

      div0.className = "printing-sprite svelte-11jgqmr";
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["addLoc"])(div0, file, 12, 4, 264);
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["setStyle"])(div1, "margin-top", "16px");
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["addLoc"])(div1, file, 13, 4, 304);
    },
    m: function mount(target, anchor) {
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["append"])(dialog._slotted["default"], div0);
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["append"])(dialog._slotted["default"], text);
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["append"])(dialog._slotted["default"], div1);

      dialog._mount(target, anchor);
    },
    d: function destroy(detach) {
      dialog.destroy(detach);
      if (component.refs.printingDialog === dialog) component.refs.printingDialog = null;
    }
  };
} // (18:0) {#if _state === STATES.FAILURE}


function create_if_block(component, ctx) {
  var if_block_anchor;
  var if_block = ctx.$transactionType && create_if_block_1(component, ctx);
  var dialog = new _mamba_dialog__WEBPACK_IMPORTED_MODULE_5__["default"]({
    root: component.root,
    store: component.store,
    slots: {
      "default": Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["createFragment"])()
    }
  });
  dialog.on("close", function (event) {
    component.fire('finish', true);
  });
  component.refs.failureDialog = dialog;
  return {
    c: function create() {
      if (if_block) if_block.c();
      if_block_anchor = Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["createComment"])();

      dialog._fragment.c();
    },
    m: function mount(target, anchor) {
      if (if_block) if_block.m(dialog._slotted["default"], null);
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["append"])(dialog._slotted["default"], if_block_anchor);

      dialog._mount(target, anchor);
    },
    p: function update(changed, ctx) {
      if (ctx.$transactionType) {
        if (!if_block) {
          if_block = create_if_block_1(component, ctx);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d: function destroy(detach) {
      if (if_block) if_block.d();
      dialog.destroy(detach);
      if (component.refs.failureDialog === dialog) component.refs.failureDialog = null;
    }
  };
} // (23:4) {#if $transactionType}


function create_if_block_1(component, ctx) {
  var img, text0, h1, text2, p, text3, strong, text5;
  return {
    c: function create() {
      img = Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["createElement"])("img");
      text0 = Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["createText"])("\n      ");
      h1 = Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["createElement"])("h1");
      h1.textContent = "ERRO NA IMPRESSO";
      text2 = Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["createText"])("\n      ");
      p = Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["createElement"])("p");
      text3 = Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["createText"])("A filipeta ainda est disponvel no app ");
      strong = Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["createElement"])("strong");
      strong.textContent = "Reimpresso";
      text5 = Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["createText"])(".");
      img.className = "failure-dialog-icon svelte-11jgqmr";
      img.src = _assets_images_icon_alert_png__WEBPACK_IMPORTED_MODULE_4___default.a;
      img.alt = "";
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["addLoc"])(img, file, 23, 6, 508);
      h1.className = "title-dialog svelte-11jgqmr";
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["addLoc"])(h1, file, 24, 6, 573);
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["addLoc"])(strong, file, 26, 48, 706);
      p.className = "failure-dialog-txt svelte-11jgqmr";
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["addLoc"])(p, file, 25, 6, 627);
    },
    m: function mount(target, anchor) {
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["insert"])(target, img, anchor);
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["insert"])(target, text0, anchor);
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["insert"])(target, h1, anchor);
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["insert"])(target, text2, anchor);
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["insert"])(target, p, anchor);
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["append"])(p, text3);
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["append"])(p, strong);
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["append"])(p, text5);
    },
    d: function destroy(detach) {
      if (detach) {
        Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["detachNode"])(img);
        Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["detachNode"])(text0);
        Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["detachNode"])(h1);
        Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["detachNode"])(text2);
        Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["detachNode"])(p);
      }
    }
  };
}

function Printable(options) {
  var _this2 = this;

  this._debugName = '<Printable>';

  if (!options || !options.target && !options.root) {
    throw new Error("'target' is a required option");
  }

  if (!options.store) {
    throw new Error("<Printable> references store properties, but no store was provided");
  }

  Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["init"])(this, options);
  this.refs = {};
  this._state = Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["assign"])(Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["assign"])(this.store._init(["transactionType"]), data()), options.data);

  this.store._add(this, ["transactionType"]);

  if (!('_paperWidth' in this._state)) console.warn("<Printable> was created without expected data property '_paperWidth'");
  if (!('_state' in this._state)) console.warn("<Printable> was created without expected data property '_state'");
  if (!('showPrintingDialog' in this._state)) console.warn("<Printable> was created without expected data property 'showPrintingDialog'");
  if (!('$transactionType' in this._state)) console.warn("<Printable> was created without expected data property '$transactionType'");
  this._intro = true;
  this._handlers.update = [onupdate];
  this._handlers.destroy = [svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["removeFromStore"]];
  this._slotted = options.slots || {};
  this._fragment = create_main_fragment(this, this._state);

  this.root._oncreate.push(function () {
    _this2.fire("update", {
      changed: Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["assignTrue"])({}, _this2._state),
      current: _this2._state
    });
  });

  if (options.target) {
    if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");

    this._fragment.c();

    this._mount(options.target, options.anchor);

    Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["flush"])(this);
  }
}

Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["assign"])(Printable.prototype, svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["protoDev"]);
Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_2__["assign"])(Printable.prototype, methods);

Printable.prototype._checkReadOnly = function _checkReadOnly(newState) {};

if (false) { var _require, configure, register, reload; }

/* harmony default export */ __webpack_exports__["default"] = (Printable);


/***/ }),

/***/ "../node_modules/@mamba/printable/Printable.svelte.css":
/*!*************************************************************!*\
  !*** ../node_modules/@mamba/printable/Printable.svelte.css ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "../node_modules/@mamba/printable/assets/images/icon-alert.png":
/*!*********************************************************************!*\
  !*** ../node_modules/@mamba/printable/assets/images/icon-alert.png ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "assets/images/icon-alert.e357b.png";

/***/ }),

/***/ "../node_modules/@mamba/styles/dist/pos.css":
/*!**************************************************!*\
  !*** ../node_modules/@mamba/styles/dist/pos.css ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "../node_modules/page/page.mjs":
/*!*************************************!*\
  !*** ../node_modules/page/page.mjs ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var core_js_modules_es_array_iterator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es.array.iterator */ "../node_modules/core-js/modules/es.array.iterator.js");
/* harmony import */ var core_js_modules_es_string_iterator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! core-js/modules/es.string.iterator */ "../node_modules/core-js/modules/es.string.iterator.js");
/* harmony import */ var core_js_modules_es_string_match__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! core-js/modules/es.string.match */ "../node_modules/core-js/modules/es.string.match.js");
/* harmony import */ var core_js_modules_es_string_repeat__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! core-js/modules/es.string.repeat */ "../node_modules/core-js/modules/es.string.repeat.js");
/* harmony import */ var core_js_modules_es_string_search__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! core-js/modules/es.string.search */ "../node_modules/core-js/modules/es.string.search.js");
/* harmony import */ var core_js_modules_web_dom_collections_iterator__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! core-js/modules/web.dom-collections.iterator */ "../node_modules/core-js/modules/web.dom-collections.iterator.js");
/* harmony import */ var core_js_modules_web_url__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! core-js/modules/web.url */ "../node_modules/core-js/modules/web.url.js");








var isarray = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};
/**
 * Expose `pathToRegexp`.
 */


var pathToRegexp_1 = pathToRegexp;
var parse_1 = parse;
var compile_1 = compile;
var tokensToFunction_1 = tokensToFunction;
var tokensToRegExp_1 = tokensToRegExp;
/**
 * The main path matching regexp utility.
 *
 * @type {RegExp}
 */

var PATH_REGEXP = new RegExp([// Match escaped characters that would otherwise appear in future matches.
// This allows the user to escape special characters that won't transform.
'(\\\\.)', // Match Express-style parameters and un-named parameters with a prefix
// and optional suffixes. Matches appear as:
//
// "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?", undefined]
// "/route(\\d+)"  => [undefined, undefined, undefined, "\d+", undefined, undefined]
// "/*"            => ["/", undefined, undefined, undefined, undefined, "*"]
'([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^()])+)\\))?|\\(((?:\\\\.|[^()])+)\\))([+*?])?|(\\*))'].join('|'), 'g');
/**
 * Parse a string for the raw tokens.
 *
 * @param  {String} str
 * @return {Array}
 */

function parse(str) {
  var tokens = [];
  var key = 0;
  var index = 0;
  var path = '';
  var res;

  while ((res = PATH_REGEXP.exec(str)) != null) {
    var m = res[0];
    var escaped = res[1];
    var offset = res.index;
    path += str.slice(index, offset);
    index = offset + m.length; // Ignore already escaped sequences.

    if (escaped) {
      path += escaped[1];
      continue;
    } // Push the current path onto the tokens.


    if (path) {
      tokens.push(path);
      path = '';
    }

    var prefix = res[2];
    var name = res[3];
    var capture = res[4];
    var group = res[5];
    var suffix = res[6];
    var asterisk = res[7];
    var repeat = suffix === '+' || suffix === '*';
    var optional = suffix === '?' || suffix === '*';
    var delimiter = prefix || '/';
    var pattern = capture || group || (asterisk ? '.*' : '[^' + delimiter + ']+?');
    tokens.push({
      name: name || key++,
      prefix: prefix || '',
      delimiter: delimiter,
      optional: optional,
      repeat: repeat,
      pattern: escapeGroup(pattern)
    });
  } // Match any characters still remaining.


  if (index < str.length) {
    path += str.substr(index);
  } // If the path exists, push it onto the end.


  if (path) {
    tokens.push(path);
  }

  return tokens;
}
/**
 * Compile a string to a template function for the path.
 *
 * @param  {String}   str
 * @return {Function}
 */


function compile(str) {
  return tokensToFunction(parse(str));
}
/**
 * Expose a method for transforming tokens into the path function.
 */


function tokensToFunction(tokens) {
  // Compile all the tokens into regexps.
  var matches = new Array(tokens.length); // Compile all the patterns before compilation.

  for (var i = 0; i < tokens.length; i++) {
    if (typeof tokens[i] === 'object') {
      matches[i] = new RegExp('^' + tokens[i].pattern + '$');
    }
  }

  return function (obj) {
    var path = '';
    var data = obj || {};

    for (var i = 0; i < tokens.length; i++) {
      var token = tokens[i];

      if (typeof token === 'string') {
        path += token;
        continue;
      }

      var value = data[token.name];
      var segment;

      if (value == null) {
        if (token.optional) {
          continue;
        } else {
          throw new TypeError('Expected "' + token.name + '" to be defined');
        }
      }

      if (isarray(value)) {
        if (!token.repeat) {
          throw new TypeError('Expected "' + token.name + '" to not repeat, but received "' + value + '"');
        }

        if (value.length === 0) {
          if (token.optional) {
            continue;
          } else {
            throw new TypeError('Expected "' + token.name + '" to not be empty');
          }
        }

        for (var j = 0; j < value.length; j++) {
          segment = encodeURIComponent(value[j]);

          if (!matches[i].test(segment)) {
            throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"');
          }

          path += (j === 0 ? token.prefix : token.delimiter) + segment;
        }

        continue;
      }

      segment = encodeURIComponent(value);

      if (!matches[i].test(segment)) {
        throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"');
      }

      path += token.prefix + segment;
    }

    return path;
  };
}
/**
 * Escape a regular expression string.
 *
 * @param  {String} str
 * @return {String}
 */


function escapeString(str) {
  return str.replace(/([.+*?=^!:${}()[\]|\/])/g, '\\$1');
}
/**
 * Escape the capturing group by escaping special characters and meaning.
 *
 * @param  {String} group
 * @return {String}
 */


function escapeGroup(group) {
  return group.replace(/([=!:$\/()])/g, '\\$1');
}
/**
 * Attach the keys as a property of the regexp.
 *
 * @param  {RegExp} re
 * @param  {Array}  keys
 * @return {RegExp}
 */


function attachKeys(re, keys) {
  re.keys = keys;
  return re;
}
/**
 * Get the flags for a regexp from the options.
 *
 * @param  {Object} options
 * @return {String}
 */


function flags(options) {
  return options.sensitive ? '' : 'i';
}
/**
 * Pull out keys from a regexp.
 *
 * @param  {RegExp} path
 * @param  {Array}  keys
 * @return {RegExp}
 */


function regexpToRegexp(path, keys) {
  // Use a negative lookahead to match only capturing groups.
  var groups = path.source.match(/\((?!\?)/g);

  if (groups) {
    for (var i = 0; i < groups.length; i++) {
      keys.push({
        name: i,
        prefix: null,
        delimiter: null,
        optional: false,
        repeat: false,
        pattern: null
      });
    }
  }

  return attachKeys(path, keys);
}
/**
 * Transform an array into a regexp.
 *
 * @param  {Array}  path
 * @param  {Array}  keys
 * @param  {Object} options
 * @return {RegExp}
 */


function arrayToRegexp(path, keys, options) {
  var parts = [];

  for (var i = 0; i < path.length; i++) {
    parts.push(pathToRegexp(path[i], keys, options).source);
  }

  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));
  return attachKeys(regexp, keys);
}
/**
 * Create a path regexp from string input.
 *
 * @param  {String} path
 * @param  {Array}  keys
 * @param  {Object} options
 * @return {RegExp}
 */


function stringToRegexp(path, keys, options) {
  var tokens = parse(path);
  var re = tokensToRegExp(tokens, options); // Attach keys back to the regexp.

  for (var i = 0; i < tokens.length; i++) {
    if (typeof tokens[i] !== 'string') {
      keys.push(tokens[i]);
    }
  }

  return attachKeys(re, keys);
}
/**
 * Expose a function for taking tokens and returning a RegExp.
 *
 * @param  {Array}  tokens
 * @param  {Array}  keys
 * @param  {Object} options
 * @return {RegExp}
 */


function tokensToRegExp(tokens, options) {
  options = options || {};
  var strict = options.strict;
  var end = options.end !== false;
  var route = '';
  var lastToken = tokens[tokens.length - 1];
  var endsWithSlash = typeof lastToken === 'string' && /\/$/.test(lastToken); // Iterate over the tokens and create our regexp string.

  for (var i = 0; i < tokens.length; i++) {
    var token = tokens[i];

    if (typeof token === 'string') {
      route += escapeString(token);
    } else {
      var prefix = escapeString(token.prefix);
      var capture = token.pattern;

      if (token.repeat) {
        capture += '(?:' + prefix + capture + ')*';
      }

      if (token.optional) {
        if (prefix) {
          capture = '(?:' + prefix + '(' + capture + '))?';
        } else {
          capture = '(' + capture + ')?';
        }
      } else {
        capture = prefix + '(' + capture + ')';
      }

      route += capture;
    }
  } // In non-strict mode we allow a slash at the end of match. If the path to
  // match already ends with a slash, we remove it for consistency. The slash
  // is valid at the end of a path match, not in the middle. This is important
  // in non-ending mode, where "/test/" shouldn't match "/test//route".


  if (!strict) {
    route = (endsWithSlash ? route.slice(0, -2) : route) + '(?:\\/(?=$))?';
  }

  if (end) {
    route += '$';
  } else {
    // In non-ending mode, we need the capturing groups to match as much as
    // possible by using a positive lookahead to the end or next path segment.
    route += strict && endsWithSlash ? '' : '(?=\\/|$)';
  }

  return new RegExp('^' + route, flags(options));
}
/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array can be passed in for the keys, which will hold the
 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
 *
 * @param  {(String|RegExp|Array)} path
 * @param  {Array}                 [keys]
 * @param  {Object}                [options]
 * @return {RegExp}
 */


function pathToRegexp(path, keys, options) {
  keys = keys || [];

  if (!isarray(keys)) {
    options = keys;
    keys = [];
  } else if (!options) {
    options = {};
  }

  if (path instanceof RegExp) {
    return regexpToRegexp(path, keys, options);
  }

  if (isarray(path)) {
    return arrayToRegexp(path, keys, options);
  }

  return stringToRegexp(path, keys, options);
}

pathToRegexp_1.parse = parse_1;
pathToRegexp_1.compile = compile_1;
pathToRegexp_1.tokensToFunction = tokensToFunction_1;
pathToRegexp_1.tokensToRegExp = tokensToRegExp_1;
/**
   * Module dependencies.
   */

/**
 * Short-cuts for global-object checks
 */

var hasDocument = 'undefined' !== typeof document;
var hasWindow = 'undefined' !== typeof window;
var hasHistory = 'undefined' !== typeof history;
var hasProcess = typeof process !== 'undefined';
/**
 * Detect click event
 */

var clickEvent = hasDocument && document.ontouchstart ? 'touchstart' : 'click';
/**
 * To work properly with the URL
 * history.location generated polyfill in https://github.com/devote/HTML5-History-API
 */

var isLocation = hasWindow && !!(window.history.location || window.location);
/**
 * The page instance
 * @api private
 */

function Page() {
  // public things
  this.callbacks = [];
  this.exits = [];
  this.current = '';
  this.len = 0; // private things

  this._decodeURLComponents = true;
  this._base = '';
  this._strict = false;
  this._running = false;
  this._hashbang = false; // bound functions

  this.clickHandler = this.clickHandler.bind(this);
  this._onpopstate = this._onpopstate.bind(this);
}
/**
 * Configure the instance of page. This can be called multiple times.
 *
 * @param {Object} options
 * @api public
 */


Page.prototype.configure = function (options) {
  var opts = options || {};
  this._window = opts.window || hasWindow && window;
  this._decodeURLComponents = opts.decodeURLComponents !== false;
  this._popstate = opts.popstate !== false && hasWindow;
  this._click = opts.click !== false && hasDocument;
  this._hashbang = !!opts.hashbang;
  var _window = this._window;

  if (this._popstate) {
    _window.addEventListener('popstate', this._onpopstate, false);
  } else if (hasWindow) {
    _window.removeEventListener('popstate', this._onpopstate, false);
  }

  if (this._click) {
    _window.document.addEventListener(clickEvent, this.clickHandler, false);
  } else if (hasDocument) {
    _window.document.removeEventListener(clickEvent, this.clickHandler, false);
  }

  if (this._hashbang && hasWindow && !hasHistory) {
    _window.addEventListener('hashchange', this._onpopstate, false);
  } else if (hasWindow) {
    _window.removeEventListener('hashchange', this._onpopstate, false);
  }
};
/**
 * Get or set basepath to `path`.
 *
 * @param {string} path
 * @api public
 */


Page.prototype.base = function (path) {
  if (0 === arguments.length) return this._base;
  this._base = path;
};
/**
 * Gets the `base`, which depends on whether we are using History or
 * hashbang routing.
  * @api private
 */


Page.prototype._getBase = function () {
  var base = this._base;
  if (!!base) return base;
  var loc = hasWindow && this._window && this._window.location;

  if (hasWindow && this._hashbang && loc && loc.protocol === 'file:') {
    base = loc.pathname;
  }

  return base;
};
/**
 * Get or set strict path matching to `enable`
 *
 * @param {boolean} enable
 * @api public
 */


Page.prototype.strict = function (enable) {
  if (0 === arguments.length) return this._strict;
  this._strict = enable;
};
/**
 * Bind with the given `options`.
 *
 * Options:
 *
 *    - `click` bind to click events [true]
 *    - `popstate` bind to popstate [true]
 *    - `dispatch` perform initial dispatch [true]
 *
 * @param {Object} options
 * @api public
 */


Page.prototype.start = function (options) {
  var opts = options || {};
  this.configure(opts);
  if (false === opts.dispatch) return;
  this._running = true;
  var url;

  if (isLocation) {
    var window = this._window;
    var loc = window.location;

    if (this._hashbang && ~loc.hash.indexOf('#!')) {
      url = loc.hash.substr(2) + loc.search;
    } else if (this._hashbang) {
      url = loc.search + loc.hash;
    } else {
      url = loc.pathname + loc.search + loc.hash;
    }
  }

  this.replace(url, null, true, opts.dispatch);
};
/**
 * Unbind click and popstate event handlers.
 *
 * @api public
 */


Page.prototype.stop = function () {
  if (!this._running) return;
  this.current = '';
  this.len = 0;
  this._running = false;
  var window = this._window;
  this._click && window.document.removeEventListener(clickEvent, this.clickHandler, false);
  hasWindow && window.removeEventListener('popstate', this._onpopstate, false);
  hasWindow && window.removeEventListener('hashchange', this._onpopstate, false);
};
/**
 * Show `path` with optional `state` object.
 *
 * @param {string} path
 * @param {Object=} state
 * @param {boolean=} dispatch
 * @param {boolean=} push
 * @return {!Context}
 * @api public
 */


Page.prototype.show = function (path, state, dispatch, push) {
  var ctx = new Context(path, state, this),
      prev = this.prevContext;
  this.prevContext = ctx;
  this.current = ctx.path;
  if (false !== dispatch) this.dispatch(ctx, prev);
  if (false !== ctx.handled && false !== push) ctx.pushState();
  return ctx;
};
/**
 * Goes back in the history
 * Back should always let the current route push state and then go back.
 *
 * @param {string} path - fallback path to go back if no more history exists, if undefined defaults to page.base
 * @param {Object=} state
 * @api public
 */


Page.prototype.back = function (path, state) {
  var page = this;

  if (this.len > 0) {
    var window = this._window; // this may need more testing to see if all browsers
    // wait for the next tick to go back in history

    hasHistory && window.history.back();
    this.len--;
  } else if (path) {
    setTimeout(function () {
      page.show(path, state);
    });
  } else {
    setTimeout(function () {
      page.show(page._getBase(), state);
    });
  }
};
/**
 * Register route to redirect from one path to other
 * or just redirect to another route
 *
 * @param {string} from - if param 'to' is undefined redirects to 'from'
 * @param {string=} to
 * @api public
 */


Page.prototype.redirect = function (from, to) {
  var inst = this; // Define route from a path to another

  if ('string' === typeof from && 'string' === typeof to) {
    page.call(this, from, function (e) {
      setTimeout(function () {
        inst.replace(
        /** @type {!string} */
        to);
      }, 0);
    });
  } // Wait for the push state and replace it with another


  if ('string' === typeof from && 'undefined' === typeof to) {
    setTimeout(function () {
      inst.replace(from);
    }, 0);
  }
};
/**
 * Replace `path` with optional `state` object.
 *
 * @param {string} path
 * @param {Object=} state
 * @param {boolean=} init
 * @param {boolean=} dispatch
 * @return {!Context}
 * @api public
 */


Page.prototype.replace = function (path, state, init, dispatch) {
  var ctx = new Context(path, state, this),
      prev = this.prevContext;
  this.prevContext = ctx;
  this.current = ctx.path;
  ctx.init = init;
  ctx.save(); // save before dispatching, which may redirect

  if (false !== dispatch) this.dispatch(ctx, prev);
  return ctx;
};
/**
 * Dispatch the given `ctx`.
 *
 * @param {Context} ctx
 * @api private
 */


Page.prototype.dispatch = function (ctx, prev) {
  var i = 0,
      j = 0,
      page = this;

  function nextExit() {
    var fn = page.exits[j++];
    if (!fn) return nextEnter();
    fn(prev, nextExit);
  }

  function nextEnter() {
    var fn = page.callbacks[i++];

    if (ctx.path !== page.current) {
      ctx.handled = false;
      return;
    }

    if (!fn) return unhandled.call(page, ctx);
    fn(ctx, nextEnter);
  }

  if (prev) {
    nextExit();
  } else {
    nextEnter();
  }
};
/**
 * Register an exit route on `path` with
 * callback `fn()`, which will be called
 * on the previous context when a new
 * page is visited.
 */


Page.prototype.exit = function (path, fn) {
  if (typeof path === 'function') {
    return this.exit('*', path);
  }

  var route = new Route(path, null, this);

  for (var i = 1; i < arguments.length; ++i) {
    this.exits.push(route.middleware(arguments[i]));
  }
};
/**
 * Handle "click" events.
 */

/* jshint +W054 */


Page.prototype.clickHandler = function (e) {
  if (1 !== this._which(e)) return;
  if (e.metaKey || e.ctrlKey || e.shiftKey) return;
  if (e.defaultPrevented) return; // ensure link
  // use shadow dom when available if not, fall back to composedPath()
  // for browsers that only have shady

  var el = e.target;
  var eventPath = e.path || (e.composedPath ? e.composedPath() : null);

  if (eventPath) {
    for (var i = 0; i < eventPath.length; i++) {
      if (!eventPath[i].nodeName) continue;
      if (eventPath[i].nodeName.toUpperCase() !== 'A') continue;
      if (!eventPath[i].href) continue;
      el = eventPath[i];
      break;
    }
  } // continue ensure link
  // el.nodeName for svg links are 'a' instead of 'A'


  while (el && 'A' !== el.nodeName.toUpperCase()) {
    el = el.parentNode;
  }

  if (!el || 'A' !== el.nodeName.toUpperCase()) return; // check if link is inside an svg
  // in this case, both href and target are always inside an object

  var svg = typeof el.href === 'object' && el.href.constructor.name === 'SVGAnimatedString'; // Ignore if tag has
  // 1. "download" attribute
  // 2. rel="external" attribute

  if (el.hasAttribute('download') || el.getAttribute('rel') === 'external') return; // ensure non-hash for the same path

  var link = el.getAttribute('href');
  if (!this._hashbang && this._samePath(el) && (el.hash || '#' === link)) return; // Check for mailto: in the href

  if (link && link.indexOf('mailto:') > -1) return; // check target
  // svg target is an object and its desired value is in .baseVal property

  if (svg ? el.target.baseVal : el.target) return; // x-origin
  // note: svg links that are not relative don't call click events (and skip page.js)
  // consequently, all svg links tested inside page.js are relative and in the same origin

  if (!svg && !this.sameOrigin(el.href)) return; // rebuild path
  // There aren't .pathname and .search properties in svg links, so we use href
  // Also, svg href is an object and its desired value is in .baseVal property

  var path = svg ? el.href.baseVal : el.pathname + el.search + (el.hash || '');
  path = path[0] !== '/' ? '/' + path : path; // strip leading "/[drive letter]:" on NW.js on Windows

  if (hasProcess && path.match(/^\/[a-zA-Z]:\//)) {
    path = path.replace(/^\/[a-zA-Z]:\//, '/');
  } // same page


  var orig = path;

  var pageBase = this._getBase();

  if (path.indexOf(pageBase) === 0) {
    path = path.substr(pageBase.length);
  }

  if (this._hashbang) path = path.replace('#!', '');

  if (pageBase && orig === path && (!isLocation || this._window.location.protocol !== 'file:')) {
    return;
  }

  e.preventDefault();
  this.show(orig);
};
/**
 * Handle "populate" events.
 * @api private
 */


Page.prototype._onpopstate = function () {
  var loaded = false;

  if (!hasWindow) {
    return function () {};
  }

  if (hasDocument && document.readyState === 'complete') {
    loaded = true;
  } else {
    window.addEventListener('load', function () {
      setTimeout(function () {
        loaded = true;
      }, 0);
    });
  }

  return function onpopstate(e) {
    if (!loaded) return;
    var page = this;

    if (e.state) {
      var path = e.state.path;
      page.replace(path, e.state);
    } else if (isLocation) {
      var loc = page._window.location;
      page.show(loc.pathname + loc.search + loc.hash, undefined, undefined, false);
    }
  };
}();
/**
 * Event button.
 */


Page.prototype._which = function (e) {
  e = e || hasWindow && this._window.event;
  return null == e.which ? e.button : e.which;
};
/**
 * Convert to a URL object
 * @api private
 */


Page.prototype._toURL = function (href) {
  var window = this._window;

  if (typeof URL === 'function' && isLocation) {
    return new URL(href, window.location.toString());
  } else if (hasDocument) {
    var anc = window.document.createElement('a');
    anc.href = href;
    return anc;
  }
};
/**
 * Check if `href` is the same origin.
 * @param {string} href
 * @api public
 */


Page.prototype.sameOrigin = function (href) {
  if (!href || !isLocation) return false;

  var url = this._toURL(href);

  var window = this._window;
  var loc = window.location;
  return loc.protocol === url.protocol && loc.hostname === url.hostname && loc.port === url.port;
};
/**
 * @api private
 */


Page.prototype._samePath = function (url) {
  if (!isLocation) return false;
  var window = this._window;
  var loc = window.location;
  return url.pathname === loc.pathname && url.search === loc.search;
};
/**
 * Remove URL encoding from the given `str`.
 * Accommodates whitespace in both x-www-form-urlencoded
 * and regular percent-encoded form.
 *
 * @param {string} val - URL component to decode
 * @api private
 */


Page.prototype._decodeURLEncodedURIComponent = function (val) {
  if (typeof val !== 'string') {
    return val;
  }

  return this._decodeURLComponents ? decodeURIComponent(val.replace(/\+/g, ' ')) : val;
};
/**
 * Create a new `page` instance and function
 */


function createPage() {
  var pageInstance = new Page();

  function pageFn()
  /* args */
  {
    return page.apply(pageInstance, arguments);
  } // Copy all of the things over. In 2.0 maybe we use setPrototypeOf


  pageFn.callbacks = pageInstance.callbacks;
  pageFn.exits = pageInstance.exits;
  pageFn.base = pageInstance.base.bind(pageInstance);
  pageFn.strict = pageInstance.strict.bind(pageInstance);
  pageFn.start = pageInstance.start.bind(pageInstance);
  pageFn.stop = pageInstance.stop.bind(pageInstance);
  pageFn.show = pageInstance.show.bind(pageInstance);
  pageFn.back = pageInstance.back.bind(pageInstance);
  pageFn.redirect = pageInstance.redirect.bind(pageInstance);
  pageFn.replace = pageInstance.replace.bind(pageInstance);
  pageFn.dispatch = pageInstance.dispatch.bind(pageInstance);
  pageFn.exit = pageInstance.exit.bind(pageInstance);
  pageFn.configure = pageInstance.configure.bind(pageInstance);
  pageFn.sameOrigin = pageInstance.sameOrigin.bind(pageInstance);
  pageFn.clickHandler = pageInstance.clickHandler.bind(pageInstance);
  pageFn.create = createPage;
  Object.defineProperty(pageFn, 'len', {
    get: function get() {
      return pageInstance.len;
    },
    set: function set(val) {
      pageInstance.len = val;
    }
  });
  Object.defineProperty(pageFn, 'current', {
    get: function get() {
      return pageInstance.current;
    },
    set: function set(val) {
      pageInstance.current = val;
    }
  }); // In 2.0 these can be named exports

  pageFn.Context = Context;
  pageFn.Route = Route;
  return pageFn;
}
/**
 * Register `path` with callback `fn()`,
 * or route `path`, or redirection,
 * or `page.start()`.
 *
 *   page(fn);
 *   page('*', fn);
 *   page('/user/:id', load, user);
 *   page('/user/' + user.id, { some: 'thing' });
 *   page('/user/' + user.id);
 *   page('/from', '/to')
 *   page();
 *
 * @param {string|!Function|!Object} path
 * @param {Function=} fn
 * @api public
 */


function page(path, fn) {
  // <callback>
  if ('function' === typeof path) {
    return page.call(this, '*', path);
  } // route <path> to <callback ...>


  if ('function' === typeof fn) {
    var route = new Route(
    /** @type {string} */
    path, null, this);

    for (var i = 1; i < arguments.length; ++i) {
      this.callbacks.push(route.middleware(arguments[i]));
    } // show <path> with [state]

  } else if ('string' === typeof path) {
    this['string' === typeof fn ? 'redirect' : 'show'](path, fn); // start [options]
  } else {
    this.start(path);
  }
}
/**
 * Unhandled `ctx`. When it's not the initial
 * popstate then redirect. If you wish to handle
 * 404s on your own use `page('*', callback)`.
 *
 * @param {Context} ctx
 * @api private
 */


function unhandled(ctx) {
  if (ctx.handled) return;
  var current;
  var page = this;
  var window = page._window;

  if (page._hashbang) {
    current = isLocation && this._getBase() + window.location.hash.replace('#!', '');
  } else {
    current = isLocation && window.location.pathname + window.location.search;
  }

  if (current === ctx.canonicalPath) return;
  page.stop();
  ctx.handled = false;
  isLocation && (window.location.href = ctx.canonicalPath);
}
/**
 * Escapes RegExp characters in the given string.
 *
 * @param {string} s
 * @api private
 */


function escapeRegExp(s) {
  return s.replace(/([.+*?=^!:${}()[\]|/\\])/g, '\\$1');
}
/**
 * Initialize a new "request" `Context`
 * with the given `path` and optional initial `state`.
 *
 * @constructor
 * @param {string} path
 * @param {Object=} state
 * @api public
 */


function Context(path, state, pageInstance) {
  var _page = this.page = pageInstance || page;

  var window = _page._window;
  var hashbang = _page._hashbang;

  var pageBase = _page._getBase();

  if ('/' === path[0] && 0 !== path.indexOf(pageBase)) path = pageBase + (hashbang ? '#!' : '') + path;
  var i = path.indexOf('?');
  this.canonicalPath = path;
  var re = new RegExp('^' + escapeRegExp(pageBase));
  this.path = path.replace(re, '') || '/';
  if (hashbang) this.path = this.path.replace('#!', '') || '/';
  this.title = hasDocument && window.document.title;
  this.state = state || {};
  this.state.path = path;
  this.querystring = ~i ? _page._decodeURLEncodedURIComponent(path.slice(i + 1)) : '';
  this.pathname = _page._decodeURLEncodedURIComponent(~i ? path.slice(0, i) : path);
  this.params = {}; // fragment

  this.hash = '';

  if (!hashbang) {
    if (!~this.path.indexOf('#')) return;
    var parts = this.path.split('#');
    this.path = this.pathname = parts[0];
    this.hash = _page._decodeURLEncodedURIComponent(parts[1]) || '';
    this.querystring = this.querystring.split('#')[0];
  }
}
/**
 * Push state.
 *
 * @api private
 */


Context.prototype.pushState = function () {
  var page = this.page;
  var window = page._window;
  var hashbang = page._hashbang;
  page.len++;

  if (hasHistory) {
    window.history.pushState(this.state, this.title, hashbang && this.path !== '/' ? '#!' + this.path : this.canonicalPath);
  }
};
/**
 * Save the context state.
 *
 * @api public
 */


Context.prototype.save = function () {
  var page = this.page;

  if (hasHistory) {
    page._window.history.replaceState(this.state, this.title, page._hashbang && this.path !== '/' ? '#!' + this.path : this.canonicalPath);
  }
};
/**
 * Initialize `Route` with the given HTTP `path`,
 * and an array of `callbacks` and `options`.
 *
 * Options:
 *
 *   - `sensitive`    enable case-sensitive routes
 *   - `strict`       enable strict matching for trailing slashes
 *
 * @constructor
 * @param {string} path
 * @param {Object=} options
 * @api private
 */


function Route(path, options, page) {
  var _page = this.page = page || globalPage;

  var opts = options || {};
  opts.strict = opts.strict || page._strict;
  this.path = path === '*' ? '(.*)' : path;
  this.method = 'GET';
  this.regexp = pathToRegexp_1(this.path, this.keys = [], opts);
}
/**
 * Return route middleware with
 * the given callback `fn()`.
 *
 * @param {Function} fn
 * @return {Function}
 * @api public
 */


Route.prototype.middleware = function (fn) {
  var self = this;
  return function (ctx, next) {
    if (self.match(ctx.path, ctx.params)) return fn(ctx, next);
    next();
  };
};
/**
 * Check if this route matches `path`, if so
 * populate `params`.
 *
 * @param {string} path
 * @param {Object} params
 * @return {boolean}
 * @api private
 */


Route.prototype.match = function (path, params) {
  var keys = this.keys,
      qsIndex = path.indexOf('?'),
      pathname = ~qsIndex ? path.slice(0, qsIndex) : path,
      m = this.regexp.exec(decodeURIComponent(pathname));
  if (!m) return false;

  for (var i = 1, len = m.length; i < len; ++i) {
    var key = keys[i - 1];

    var val = this.page._decodeURLEncodedURIComponent(m[i]);

    if (val !== undefined || !hasOwnProperty.call(params, key.name)) {
      params[key.name] = val;
    }
  }

  return true;
};
/**
 * Module exports.
 */


var globalPage = createPage();
var page_js = globalPage;
var default_1 = globalPage;
page_js["default"] = default_1;
/* harmony default export */ __webpack_exports__["default"] = (page_js);

/***/ }),

/***/ "../node_modules/regenerator-runtime/runtime.js":
/*!******************************************************!*\
  !*** ../node_modules/regenerator-runtime/runtime.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(/*! core-js/modules/es.symbol */ "../node_modules/core-js/modules/es.symbol.js");

__webpack_require__(/*! core-js/modules/es.symbol.description */ "../node_modules/core-js/modules/es.symbol.description.js");

__webpack_require__(/*! core-js/modules/es.symbol.async-iterator */ "../node_modules/core-js/modules/es.symbol.async-iterator.js");

__webpack_require__(/*! core-js/modules/es.symbol.iterator */ "../node_modules/core-js/modules/es.symbol.iterator.js");

__webpack_require__(/*! core-js/modules/es.symbol.to-string-tag */ "../node_modules/core-js/modules/es.symbol.to-string-tag.js");

__webpack_require__(/*! core-js/modules/es.array.iterator */ "../node_modules/core-js/modules/es.array.iterator.js");

__webpack_require__(/*! core-js/modules/es.array.reverse */ "../node_modules/core-js/modules/es.array.reverse.js");

__webpack_require__(/*! core-js/modules/es.json.to-string-tag */ "../node_modules/core-js/modules/es.json.to-string-tag.js");

__webpack_require__(/*! core-js/modules/es.math.to-string-tag */ "../node_modules/core-js/modules/es.math.to-string-tag.js");

__webpack_require__(/*! core-js/modules/es.object.get-prototype-of */ "../node_modules/core-js/modules/es.object.get-prototype-of.js");

__webpack_require__(/*! core-js/modules/es.object.set-prototype-of */ "../node_modules/core-js/modules/es.object.set-prototype-of.js");

__webpack_require__(/*! core-js/modules/es.promise */ "../node_modules/core-js/modules/es.promise.js");

__webpack_require__(/*! core-js/modules/es.string.iterator */ "../node_modules/core-js/modules/es.string.iterator.js");

__webpack_require__(/*! core-js/modules/web.dom-collections.for-each */ "../node_modules/core-js/modules/web.dom-collections.for-each.js");

__webpack_require__(/*! core-js/modules/web.dom-collections.iterator */ "../node_modules/core-js/modules/web.dom-collections.iterator.js");

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var runtime = function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.

  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.

    generator._invoke = makeInvokeMethod(innerFn, self, context);
    return generator;
  }

  exports.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.

  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed"; // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.

  var ContinueSentinel = {}; // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.

  function Generator() {}

  function GeneratorFunction() {}

  function GeneratorFunctionPrototype() {} // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.


  var IteratorPrototype = {};

  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));

  if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction"; // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.

  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      prototype[method] = function (arg) {
        return this._invoke(method, arg);
      };
    });
  }

  exports.isGeneratorFunction = function (genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can
    // do is to check its .name property.
    (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
  };

  exports.mark = function (genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;

      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }

    genFun.prototype = Object.create(Gp);
    return genFun;
  }; // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.


  exports.awrap = function (arg) {
    return {
      __await: arg
    };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);

      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;

        if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function (value) {
            invoke("next", value, resolve, reject);
          }, function (err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function (unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function (error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function (resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise = // If enqueue has been called before, then we want to wait until
      // all previous Promises have been resolved before calling invoke,
      // so that results are always delivered in the correct order. If
      // enqueue has not been called before, then it is important to
      // call invoke immediately, without waiting on a callback to fire,
      // so that the async generator function has the opportunity to do
      // any necessary setup in a predictable way. This predictability
      // is why the Promise constructor synchronously invokes its
      // executor callback, and why async functions synchronously
      // execute code before the first await. Since we implement simple
      // async functions in terms of async generators, it is especially
      // important to get this right, even though it requires care.
      previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later
      // invocations of the iterator.
      callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
    } // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).


    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);

  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };

  exports.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.

  exports.async = function (innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList));
    return exports.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
    : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;
    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        } // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume


        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;

        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);

          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;
        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);
        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;
        var record = tryCatch(innerFn, self, context);

        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done ? GenStateCompleted : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };
        } else if (record.type === "throw") {
          state = GenStateCompleted; // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.

          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  } // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.


  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];

    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError("The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (!info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield).

      context.next = delegate.nextLoc; // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.

      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }
    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    } // The delegate iterator is finished, so forget it and continue with
    // the outer generator.


    context.delegate = null;
    return ContinueSentinel;
  } // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.


  defineIteratorMethods(Gp);
  Gp[toStringTagSymbol] = "Generator"; // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.

  Gp[iteratorSymbol] = function () {
    return this;
  };

  Gp.toString = function () {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{
      tryLoc: "root"
    }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function (object) {
    var keys = [];

    for (var key in object) {
      keys.push(key);
    }

    keys.reverse(); // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.

    return function next() {
      while (keys.length) {
        var key = keys.pop();

        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      } // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.


      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];

      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1,
            next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;
          return next;
        };

        return next.next = next;
      }
    } // Return an iterator with no values.


    return {
      next: doneResult
    };
  }

  exports.values = values;

  function doneResult() {
    return {
      value: undefined,
      done: true
    };
  }

  Context.prototype = {
    constructor: Context,
    reset: function reset(skipTempReset) {
      this.prev = 0;
      this.next = 0; // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.

      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;
      this.method = "next";
      this.arg = undefined;
      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },
    stop: function stop() {
      this.done = true;
      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;

      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },
    dispatchException: function dispatchException(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;

      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !!caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }
          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },
    abrupt: function abrupt(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },
    complete: function complete(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" || record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },
    finish: function finish(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },
    "catch": function _catch(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;

          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }

          return thrown;
        }
      } // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.


      throw new Error("illegal catch attempt");
    },
    delegateYield: function delegateYield(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  }; // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.

  return exports;
}( // If this script is executing as a CommonJS module, use module.exports
// as the regeneratorRuntime namespace. Otherwise create a new empty
// object. Either way, the resulting object will be used to initialize
// the regeneratorRuntime variable at the top of this file.
 true ? module.exports : undefined);

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  Function("r", "regeneratorRuntime = r")(runtime);
}

/***/ }),

/***/ "../node_modules/svelte-page/NestedRoute.html":
/*!****************************************************!*\
  !*** ../node_modules/svelte-page/NestedRoute.html ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/shared.js */ "../node_modules/svelte/shared.js");
/* node_modules/svelte-page/NestedRoute.html generated by Svelte v2.16.1 */


function data() {
  return {
    page: null
  };
}

;

function onupdate(_ref) {
  var changed = _ref.changed,
      current = _ref.current;

  if (changed.page && current.page == null) {
    this.fire('notFound');
  }
}

;
var file = "node_modules/svelte-page/NestedRoute.html";

function create_main_fragment(component, ctx) {
  var if_block_anchor;

  function select_block_type(ctx) {
    if (ctx.page) return create_if_block;
    return create_else_block;
  }

  var current_block_type = select_block_type(ctx);
  var if_block = current_block_type(component, ctx);
  return {
    c: function create() {
      if_block.c();
      if_block_anchor = Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["createComment"])();
    },
    m: function mount(target, anchor) {
      if_block.m(target, anchor);
      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["insert"])(target, if_block_anchor, anchor);
    },
    p: function update(changed, ctx) {
      if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
        if_block.p(changed, ctx);
      } else {
        if_block.d(1);
        if_block = current_block_type(component, ctx);
        if_block.c();
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    d: function destroy(detach) {
      if_block.d(detach);

      if (detach) {
        Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["detachNode"])(if_block_anchor);
      }
    }
  };
} // (9:0) {:else}


function create_else_block(component, ctx) {
  var slot_content_default = component._slotted["default"],
      slot_content_default_before,
      slot_content_default_after;
  return {
    c: svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["noop"],
    m: function mount(target, anchor) {
      if (slot_content_default) {
        Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["insert"])(target, slot_content_default_before || (slot_content_default_before = Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["createComment"])()), anchor);
        Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["insert"])(target, slot_content_default, anchor);
        Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["insert"])(target, slot_content_default_after || (slot_content_default_after = Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["createComment"])()), anchor);
      }
    },
    p: svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["noop"],
    d: function destroy(detach) {
      if (slot_content_default) {
        Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["reinsertBetween"])(slot_content_default_before, slot_content_default_after, slot_content_default);
        Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["detachNode"])(slot_content_default_before);
        Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["detachNode"])(slot_content_default_after);
      }
    }
  };
} // (1:0) {#if page}


function create_if_block(component, ctx) {
  var switch_instance_anchor;
  var switch_instance_spread_levels = [ctx.page.props];
  var switch_value = ctx.page.child;

  function switch_props(ctx) {
    var switch_instance_initial_data = {};

    for (var i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_initial_data = Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["assign"])(switch_instance_initial_data, switch_instance_spread_levels[i]);
    }

    return {
      root: component.root,
      store: component.store,
      data: switch_instance_initial_data
    };
  }

  if (switch_value) {
    var switch_instance = new switch_value(switch_props(ctx));
  }

  function switch_instance_action(event) {
    component.fire("action", event);
  }

  if (switch_instance) switch_instance.on("action", switch_instance_action);

  function switch_instance_response(event) {
    component.fire("response", event);
  }

  if (switch_instance) switch_instance.on("response", switch_instance_response);

  function switch_instance_event(event) {
    component.fire("event", event);
  }

  if (switch_instance) switch_instance.on("event", switch_instance_event);
  return {
    c: function create() {
      if (switch_instance) switch_instance._fragment.c();
      switch_instance_anchor = Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["createComment"])();
    },
    m: function mount(target, anchor) {
      if (switch_instance) {
        switch_instance._mount(target, anchor);
      }

      Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["insert"])(target, switch_instance_anchor, anchor);
    },
    p: function update(changed, ctx) {
      var switch_instance_changes = changed.page ? Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["getSpreadUpdate"])(switch_instance_spread_levels, [ctx.page.props]) : {};

      if (switch_value !== (switch_value = ctx.page.child)) {
        if (switch_instance) {
          switch_instance.destroy();
        }

        if (switch_value) {
          switch_instance = new switch_value(switch_props(ctx));

          switch_instance._fragment.c();

          switch_instance._mount(switch_instance_anchor.parentNode, switch_instance_anchor);

          switch_instance.on("action", switch_instance_action);
          switch_instance.on("response", switch_instance_response);
          switch_instance.on("event", switch_instance_event);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance._set(switch_instance_changes);
      }
    },
    d: function destroy(detach) {
      if (detach) {
        Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["detachNode"])(switch_instance_anchor);
      }

      if (switch_instance) switch_instance.destroy(detach);
    }
  };
}

function NestedRoute(options) {
  var _this = this;

  this._debugName = '<NestedRoute>';

  if (!options || !options.target && !options.root) {
    throw new Error("'target' is a required option");
  }

  Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["init"])(this, options);
  this._state = Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["assign"])(data(), options.data);
  if (!('page' in this._state)) console.warn("<NestedRoute> was created without expected data property 'page'");
  this._intro = true;
  this._handlers.update = [onupdate];
  this._slotted = options.slots || {};
  this._fragment = create_main_fragment(this, this._state);

  this.root._oncreate.push(function () {
    _this.fire("update", {
      changed: Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["assignTrue"])({}, _this._state),
      current: _this._state
    });
  });

  if (options.target) {
    if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");

    this._fragment.c();

    this._mount(options.target, options.anchor);

    Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["flush"])(this);
  }
}

Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["assign"])(NestedRoute.prototype, svelte_shared_js__WEBPACK_IMPORTED_MODULE_0__["protoDev"]);

NestedRoute.prototype._checkReadOnly = function _checkReadOnly(newState) {};

if (false) { var _require, configure, register, reload; }

/* harmony default export */ __webpack_exports__["default"] = (NestedRoute);

/***/ }),

/***/ "../node_modules/svelte-page/Router.html":
/*!***********************************************!*\
  !*** ../node_modules/svelte-page/Router.html ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var core_js_modules_web_dom_collections_for_each__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/web.dom-collections.for-each */ "../node_modules/core-js/modules/web.dom-collections.for-each.js");
/* harmony import */ var core_js_modules_web_dom_collections_for_each__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_web_dom_collections_for_each__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var svelte_shared_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! svelte/shared.js */ "../node_modules/svelte/shared.js");
/* harmony import */ var page__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! page */ "../node_modules/page/page.mjs");
/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./helpers.js */ "../node_modules/svelte-page/helpers.js");
/* harmony import */ var _NestedRoute_html__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./NestedRoute.html */ "../node_modules/svelte-page/NestedRoute.html");


/* node_modules/svelte-page/Router.html generated by Svelte v2.16.1 */




var currentCtx = null;
/**
 * Stack of page instances.
 * Allow to use 'static' methods for the 'last' available router
 */

var pageInstances = [];

function data() {
  return {
    page: null,
    strict: true,
    hashbang: true,
    context: null
  };
}

;

function oncreate() {
  var _this = this;

  var _this$get = this.get(),
      routes = _this$get.routes,
      strict = _this$get.strict,
      hashbang = _this$get.hashbang;

  this.pageInstance = page__WEBPACK_IMPORTED_MODULE_2__["default"].create(); // TODO: maybe remove in V3

  this.push = this.go = this.pageInstance.show;
  this.back = this.pageInstance.back;
  pageInstances.push(this.pageInstance);
  /** Set up the component hierarchy */

  this.pageInstance('*', function (ctx, next) {
    ctx.components = [];
    next();
  });
  /** Generate page routes */

  Object.keys(routes).forEach(function (path) {
    return _this.pageInstance(path, Object(_helpers_js__WEBPACK_IMPORTED_MODULE_3__["getRouteMiddleware"])(path, routes));
  });
  /** Translate component array into svelte state */

  this.pageInstance('*', function (ctx) {
    var components = ctx.components;
    var props = {
      page: null,
      context: ctx
    };
    /** Data needs to always be an object or else nesting won't work */

    components.reduce(function (prev, _ref) {
      var component = _ref.component,
          _ref$data = _ref.data,
          data = _ref$data === void 0 ? {} : _ref$data;
      data.page = null;
      prev.page = {
        child: component,
        props: data
      };
      return prev.page.props;
    }, props);

    _this.set(props);

    currentCtx = ctx;

    _this.fire('change', ctx);

    _this.root.fire('router:change', ctx);
  });
  /** Allow trailing slash */

  this.pageInstance.strict(strict);
  /** Start the router */

  this.pageInstance.start({
    hashbang: hashbang
  });
}

;

function ondestroy() {
  this.pageInstance.stop();
  this.pageInstance.prevContext = undefined;
  this.pageInstance.callbacks.length = 0;
  this.pageInstance.exits.length = 0;
  pageInstances.pop(this.pageInstance);
}

;

function onstate(_ref2) {
  var previous = _ref2.previous;

  if (!previous) {
    this.root.router = this;
  }
}

;

function setup(Router) {
  Router.push = Router.go = function () {
    var _pageInstances;

    return (_pageInstances = pageInstances[pageInstances.length - 1]).show.apply(_pageInstances, arguments);
  };

  Router.back = function () {
    var _pageInstances2;

    return (_pageInstances2 = pageInstances[pageInstances.length - 1]).back.apply(_pageInstances2, arguments);
  };

  Router.getContext = function () {
    return currentCtx;
  };

  Router.getPath = function () {
    return currentCtx.path;
  };
}

;
var file = "node_modules/svelte-page/Router.html";

function create_main_fragment(component, ctx) {
  var slot_content_default = component._slotted["default"];
  var nestedroute_initial_data = {
    page: ctx.page
  };
  var nestedroute = new _NestedRoute_html__WEBPACK_IMPORTED_MODULE_4__["default"]({
    root: component.root,
    store: component.store,
    slots: {
      "default": Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_1__["createFragment"])()
    },
    data: nestedroute_initial_data
  });
  nestedroute.on("notFound", function (event) {
    component.fire("notFound", event);
  });
  return {
    c: function create() {
      nestedroute._fragment.c();
    },
    m: function mount(target, anchor) {
      if (slot_content_default) {
        Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_1__["append"])(nestedroute._slotted["default"], slot_content_default);
      }

      nestedroute._mount(target, anchor);
    },
    p: function update(changed, ctx) {
      var nestedroute_changes = {};
      if (changed.page) nestedroute_changes.page = ctx.page;

      nestedroute._set(nestedroute_changes);
    },
    d: function destroy(detach) {
      if (slot_content_default) {
        Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_1__["reinsertChildren"])(nestedroute._slotted["default"], slot_content_default);
      }

      nestedroute.destroy(detach);
    }
  };
}

function Router(options) {
  var _this2 = this;

  this._debugName = '<Router>';

  if (!options || !options.target && !options.root) {
    throw new Error("'target' is a required option");
  }

  Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_1__["init"])(this, options);
  this._state = Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_1__["assign"])(data(), options.data);
  if (!('page' in this._state)) console.warn("<Router> was created without expected data property 'page'");
  this._intro = true;
  this._handlers.state = [onstate];
  this._handlers.destroy = [ondestroy];
  this._slotted = options.slots || {};
  onstate.call(this, {
    changed: Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_1__["assignTrue"])({}, this._state),
    current: this._state
  });
  this._fragment = create_main_fragment(this, this._state);

  this.root._oncreate.push(function () {
    oncreate.call(_this2);

    _this2.fire("update", {
      changed: Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_1__["assignTrue"])({}, _this2._state),
      current: _this2._state
    });
  });

  if (options.target) {
    if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");

    this._fragment.c();

    this._mount(options.target, options.anchor);

    Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_1__["flush"])(this);
  }
}

Object(svelte_shared_js__WEBPACK_IMPORTED_MODULE_1__["assign"])(Router.prototype, svelte_shared_js__WEBPACK_IMPORTED_MODULE_1__["protoDev"]);

Router.prototype._checkReadOnly = function _checkReadOnly(newState) {};

setup(Router);

if (false) { var _require, configure, register, reload; }

/* harmony default export */ __webpack_exports__["default"] = (Router);

/***/ }),

/***/ "../node_modules/svelte-page/helpers.js":
/*!**********************************************!*\
  !*** ../node_modules/svelte-page/helpers.js ***!
  \**********************************************/
/*! exports provided: getRouteMiddleware, getSveltedHierarchy */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getRouteMiddleware", function() { return getRouteMiddleware; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSveltedHierarchy", function() { return getSveltedHierarchy; });
/* harmony import */ var core_js_modules_es_object_assign__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es.object.assign */ "../node_modules/core-js/modules/es.object.assign.js");
/* harmony import */ var core_js_modules_es_object_assign__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_assign__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_web_dom_collections_for_each__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! core-js/modules/web.dom-collections.for-each */ "../node_modules/core-js/modules/web.dom-collections.for-each.js");
/* harmony import */ var core_js_modules_web_dom_collections_for_each__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_web_dom_collections_for_each__WEBPACK_IMPORTED_MODULE_1__);



function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

/** Creates a route callback with the specified data */
var getRouteMiddleware = function getRouteMiddleware(routePath, routes) {
  if (routes[routePath].constructor !== Object) {
    routes[routePath] = {
      component: routes[routePath]
    };
  }

  var _routes$routePath = routes[routePath],
      _routes$routePath$dat = _routes$routePath.data,
      data = _routes$routePath$dat === void 0 ? {} : _routes$routePath$dat,
      loader = _routes$routePath.loader;
  var hasPreloaded = false;

  var loadPreloads = function loadPreloads() {
    var preload = routes[routePath].preload;
    setTimeout(function () {
      return preload.forEach(function (preloadRoute) {
        var loader = routes[preloadRoute].loader;

        if (typeof loader === 'function') {
          loader().then(function (_ref) {
            var component = _ref["default"];
            routes[preloadRoute].component = component;
          });
        }
      });
    });
    hasPreloaded = true;
  };

  return function (ctx, next) {
    var components = ctx.components,
        params = ctx.params,
        _ctx$state = ctx.state,
        path = _ctx$state.path,
        state = _objectWithoutPropertiesLoose(_ctx$state, ["path"]);

    var _routes$routePath2 = routes[routePath],
        component = _routes$routePath2.component,
        preload = _routes$routePath2.preload;
    /** Remove pathregexp path match */

    delete params[0];
    var routeData = Object.assign({}, data, state, {
      params: params
    });
    /** If no component present and */

    if (!component) {
      /** If there's a loader function, load it */
      if (typeof loader === 'function') {
        loader().then(function (_ref2) {
          var component = _ref2["default"];
          components.push({
            component: component,
            data: routeData
          });

          if (preload && !hasPreloaded) {
            loadPreloads();
          }

          next();
        });
      } else {
        throw new Error("[svelte-router] No component for route \"" + routePath + "\"");
      }

      return;
    }

    components.push({
      component: component,
      data: routeData
    });

    if (preload && !hasPreloaded) {
      loadPreloads();
    }

    next();
  };
};
var getSveltedHierarchy = function getSveltedHierarchy(Router) {
  return function (ctx) {
    var components = ctx.components;
    var props = {
      page: null,
      context: ctx,
      path: ctx.path
    };
    /** Data needs to always be an object or else nesting won't work */

    components.reduce(function (prev, _ref3) {
      var component = _ref3.component,
          _ref3$data = _ref3.data,
          data = _ref3$data === void 0 ? {} : _ref3$data;
      data.page = null;
      prev.page = {
        child: component,
        props: data
      };
      return prev.page.props;
    }, props);

    if (Router.store) {
      Router.store.fire('router:beforeNavigation', ctx);
    }

    Router.set(props);

    if (Router.store) {
      Router.store.fire('router:navigation', ctx);
    }
  };
};

/***/ }),

/***/ "../node_modules/svelte/shared.js":
/*!****************************************!*\
  !*** ../node_modules/svelte/shared.js ***!
  \****************************************/
/*! exports provided: blankObject, destroy, destroyDev, _differs, _differsImmutable, fire, flush, get, init, on, set, _set, _stage, setDev, callAll, _mount, PENDING, SUCCESS, FAILURE, removeFromStore, proto, protoDev, wrapAnimation, fixPosition, handlePromise, append, insert, detachNode, detachBetween, detachBefore, detachAfter, reinsertBetween, reinsertChildren, reinsertAfter, reinsertBefore, destroyEach, createFragment, createElement, createSvgElement, createText, createComment, addListener, removeListener, setAttribute, setAttributes, setCustomElementData, setXlinkAttribute, getBindingGroupValue, toNumber, timeRangesToArray, children, claimElement, claimText, setData, setInputType, setStyle, selectOption, selectOptions, selectValue, selectMultipleValue, addResizeListener, toggleClass, destroyBlock, outroAndDestroyBlock, fixAndOutroAndDestroyBlock, updateKeyedEach, measure, animate, getSpreadUpdate, invalidAttributeNameCharacter, spread, escaped, escape, each, missingComponent, validateSsrComponent, debug, linear, generateRule, hash, wrapTransition, outros, groupOutros, transitionManager, noop, assign, assignTrue, isPromise, callAfter, addLoc, exclude, run */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "blankObject", function() { return blankObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "destroy", function() { return destroy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "destroyDev", function() { return destroyDev; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_differs", function() { return _differs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_differsImmutable", function() { return _differsImmutable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fire", function() { return fire; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "flush", function() { return flush; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "get", function() { return get; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "on", function() { return on; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_set", function() { return _set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_stage", function() { return _stage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setDev", function() { return setDev; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "callAll", function() { return callAll; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_mount", function() { return _mount; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PENDING", function() { return PENDING; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SUCCESS", function() { return SUCCESS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FAILURE", function() { return FAILURE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeFromStore", function() { return removeFromStore; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "proto", function() { return proto; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "protoDev", function() { return protoDev; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "wrapAnimation", function() { return wrapAnimation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fixPosition", function() { return fixPosition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "handlePromise", function() { return handlePromise; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "append", function() { return append; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "insert", function() { return insert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "detachNode", function() { return detachNode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "detachBetween", function() { return detachBetween; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "detachBefore", function() { return detachBefore; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "detachAfter", function() { return detachAfter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reinsertBetween", function() { return reinsertBetween; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reinsertChildren", function() { return reinsertChildren; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reinsertAfter", function() { return reinsertAfter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reinsertBefore", function() { return reinsertBefore; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "destroyEach", function() { return destroyEach; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createFragment", function() { return createFragment; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createElement", function() { return createElement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createSvgElement", function() { return createSvgElement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createText", function() { return createText; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createComment", function() { return createComment; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addListener", function() { return addListener; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeListener", function() { return removeListener; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setAttribute", function() { return setAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setAttributes", function() { return setAttributes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setCustomElementData", function() { return setCustomElementData; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setXlinkAttribute", function() { return setXlinkAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBindingGroupValue", function() { return getBindingGroupValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toNumber", function() { return toNumber; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "timeRangesToArray", function() { return timeRangesToArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "children", function() { return children; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "claimElement", function() { return claimElement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "claimText", function() { return claimText; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setData", function() { return setData; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setInputType", function() { return setInputType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setStyle", function() { return setStyle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "selectOption", function() { return selectOption; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "selectOptions", function() { return selectOptions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "selectValue", function() { return selectValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "selectMultipleValue", function() { return selectMultipleValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addResizeListener", function() { return addResizeListener; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toggleClass", function() { return toggleClass; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "destroyBlock", function() { return destroyBlock; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "outroAndDestroyBlock", function() { return outroAndDestroyBlock; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fixAndOutroAndDestroyBlock", function() { return fixAndOutroAndDestroyBlock; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "updateKeyedEach", function() { return updateKeyedEach; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "measure", function() { return measure; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "animate", function() { return animate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSpreadUpdate", function() { return getSpreadUpdate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "invalidAttributeNameCharacter", function() { return invalidAttributeNameCharacter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "spread", function() { return spread; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "escaped", function() { return escaped; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "escape", function() { return escape; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "each", function() { return each; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "missingComponent", function() { return missingComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "validateSsrComponent", function() { return validateSsrComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "debug", function() { return debug; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linear", function() { return linear; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "generateRule", function() { return generateRule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hash", function() { return hash; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "wrapTransition", function() { return wrapTransition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "outros", function() { return outros; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "groupOutros", function() { return groupOutros; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transitionManager", function() { return transitionManager; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "noop", function() { return noop; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "assign", function() { return assign; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "assignTrue", function() { return assignTrue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isPromise", function() { return isPromise; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "callAfter", function() { return callAfter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addLoc", function() { return addLoc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exclude", function() { return exclude; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "run", function() { return run; });
/* harmony import */ var core_js_modules_es_array_from__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es.array.from */ "../node_modules/core-js/modules/es.array.from.js");
/* harmony import */ var core_js_modules_es_array_from__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_from__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es_object_assign__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! core-js/modules/es.object.assign */ "../node_modules/core-js/modules/es.object.assign.js");
/* harmony import */ var core_js_modules_es_object_assign__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_assign__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var core_js_modules_es_promise__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! core-js/modules/es.promise */ "../node_modules/core-js/modules/es.promise.js");
/* harmony import */ var core_js_modules_es_promise__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_promise__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var core_js_modules_es_string_iterator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! core-js/modules/es.string.iterator */ "../node_modules/core-js/modules/es.string.iterator.js");
/* harmony import */ var core_js_modules_es_string_iterator__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_string_iterator__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var core_js_modules_web_dom_collections_for_each__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! core-js/modules/web.dom-collections.for-each */ "../node_modules/core-js/modules/web.dom-collections.for-each.js");
/* harmony import */ var core_js_modules_web_dom_collections_for_each__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_web_dom_collections_for_each__WEBPACK_IMPORTED_MODULE_4__);






function noop() {}

function assign(tar, src) {
  for (var k in src) {
    tar[k] = src[k];
  }

  return tar;
}

function assignTrue(tar, src) {
  for (var k in src) {
    tar[k] = 1;
  }

  return tar;
}

function isPromise(value) {
  return value && typeof value.then === 'function';
}

function callAfter(fn, i) {
  if (i === 0) fn();
  return function () {
    if (! --i) fn();
  };
}

function addLoc(element, file, line, column, _char) {
  element.__svelte_meta = {
    loc: {
      file: file,
      line: line,
      column: column,
      "char": _char
    }
  };
}

function exclude(src, prop) {
  var tar = {};

  for (var k in src) {
    k === prop || (tar[k] = src[k]);
  }

  return tar;
}

function run(fn) {
  fn();
}

function append(target, node) {
  target.appendChild(node);
}

function insert(target, node, anchor) {
  target.insertBefore(node, anchor);
}

function detachNode(node) {
  node.parentNode.removeChild(node);
}

function detachBetween(before, after) {
  while (before.nextSibling && before.nextSibling !== after) {
    before.parentNode.removeChild(before.nextSibling);
  }
}

function detachBefore(after) {
  while (after.previousSibling) {
    after.parentNode.removeChild(after.previousSibling);
  }
}

function detachAfter(before) {
  while (before.nextSibling) {
    before.parentNode.removeChild(before.nextSibling);
  }
}

function reinsertBetween(before, after, target) {
  while (before.nextSibling && before.nextSibling !== after) {
    target.appendChild(before.parentNode.removeChild(before.nextSibling));
  }
}

function reinsertChildren(parent, target) {
  while (parent.firstChild) {
    target.appendChild(parent.firstChild);
  }
}

function reinsertAfter(before, target) {
  while (before.nextSibling) {
    target.appendChild(before.nextSibling);
  }
}

function reinsertBefore(after, target) {
  var parent = after.parentNode;

  while (parent.firstChild !== after) {
    target.appendChild(parent.firstChild);
  }
}

function destroyEach(iterations, detach) {
  for (var i = 0; i < iterations.length; i += 1) {
    if (iterations[i]) iterations[i].d(detach);
  }
}

function createFragment() {
  return document.createDocumentFragment();
}

function createElement(name) {
  return document.createElement(name);
}

function createSvgElement(name) {
  return document.createElementNS('http://www.w3.org/2000/svg', name);
}

function createText(data) {
  return document.createTextNode(data);
}

function createComment() {
  return document.createComment('');
}

function addListener(node, event, handler, options) {
  node.addEventListener(event, handler, options);
}

function removeListener(node, event, handler, options) {
  node.removeEventListener(event, handler, options);
}

function setAttribute(node, attribute, value) {
  if (value == null) node.removeAttribute(attribute);else node.setAttribute(attribute, value);
}

function setAttributes(node, attributes) {
  for (var key in attributes) {
    if (key === 'style') {
      node.style.cssText = attributes[key];
    } else if (key in node) {
      node[key] = attributes[key];
    } else {
      setAttribute(node, key, attributes[key]);
    }
  }
}

function setCustomElementData(node, prop, value) {
  if (prop in node) {
    node[prop] = value;
  } else {
    setAttribute(node, prop, value);
  }
}

function setXlinkAttribute(node, attribute, value) {
  node.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);
}

function getBindingGroupValue(group) {
  var value = [];

  for (var i = 0; i < group.length; i += 1) {
    if (group[i].checked) value.push(group[i].__value);
  }

  return value;
}

function toNumber(value) {
  return value === '' ? undefined : +value;
}

function timeRangesToArray(ranges) {
  var array = [];

  for (var i = 0; i < ranges.length; i += 1) {
    array.push({
      start: ranges.start(i),
      end: ranges.end(i)
    });
  }

  return array;
}

function children(element) {
  return Array.from(element.childNodes);
}

function claimElement(nodes, name, attributes, svg) {
  for (var i = 0; i < nodes.length; i += 1) {
    var node = nodes[i];

    if (node.nodeName === name) {
      for (var j = 0; j < node.attributes.length; j += 1) {
        var attribute = node.attributes[j];
        if (!attributes[attribute.name]) node.removeAttribute(attribute.name);
      }

      return nodes.splice(i, 1)[0]; // TODO strip unwanted attributes
    }
  }

  return svg ? createSvgElement(name) : createElement(name);
}

function claimText(nodes, data) {
  for (var i = 0; i < nodes.length; i += 1) {
    var node = nodes[i];

    if (node.nodeType === 3) {
      node.data = data;
      return nodes.splice(i, 1)[0];
    }
  }

  return createText(data);
}

function setData(text, data) {
  text.data = '' + data;
}

function setInputType(input, type) {
  try {
    input.type = type;
  } catch (e) {}
}

function setStyle(node, key, value) {
  node.style.setProperty(key, value);
}

function selectOption(select, value) {
  for (var i = 0; i < select.options.length; i += 1) {
    var option = select.options[i];

    if (option.__value === value) {
      option.selected = true;
      return;
    }
  }
}

function selectOptions(select, value) {
  for (var i = 0; i < select.options.length; i += 1) {
    var option = select.options[i];
    option.selected = ~value.indexOf(option.__value);
  }
}

function selectValue(select) {
  var selectedOption = select.querySelector(':checked') || select.options[0];
  return selectedOption && selectedOption.__value;
}

function selectMultipleValue(select) {
  return [].map.call(select.querySelectorAll(':checked'), function (option) {
    return option.__value;
  });
}

function addResizeListener(element, fn) {
  if (getComputedStyle(element).position === 'static') {
    element.style.position = 'relative';
  }

  var object = document.createElement('object');
  object.setAttribute('style', 'display: block; position: absolute; top: 0; left: 0; height: 100%; width: 100%; overflow: hidden; pointer-events: none; z-index: -1;');
  object.type = 'text/html';
  var win;

  object.onload = function () {
    win = object.contentDocument.defaultView;
    win.addEventListener('resize', fn);
  };

  if (/Trident/.test(navigator.userAgent)) {
    element.appendChild(object);
    object.data = 'about:blank';
  } else {
    object.data = 'about:blank';
    element.appendChild(object);
  }

  return {
    cancel: function cancel() {
      win && win.removeEventListener && win.removeEventListener('resize', fn);
      element.removeChild(object);
    }
  };
}

function toggleClass(element, name, toggle) {
  element.classList[toggle ? 'add' : 'remove'](name);
}

function linear(t) {
  return t;
}

function generateRule(_ref, ease, fn) {
  var a = _ref.a,
      b = _ref.b,
      delta = _ref.delta,
      duration = _ref.duration;
  var step = 16.666 / duration;
  var keyframes = '{\n';

  for (var p = 0; p <= 1; p += step) {
    var t = a + delta * ease(p);
    keyframes += p * 100 + ("%{" + fn(t, 1 - t) + "}\n");
  }

  return keyframes + ("100% {" + fn(b, 1 - b) + "}\n}");
} // https://github.com/darkskyapp/string-hash/blob/master/index.js


function hash(str) {
  var hash = 5381;
  var i = str.length;

  while (i--) {
    hash = (hash << 5) - hash ^ str.charCodeAt(i);
  }

  return hash >>> 0;
}

function wrapTransition(component, node, fn, params, intro) {
  var obj = fn.call(component, node, params);
  var duration;
  var ease;
  var cssText;
  var initialised = false;
  return {
    t: intro ? 0 : 1,
    running: false,
    program: null,
    pending: null,
    run: function run(b, callback) {
      var _this = this;

      if (typeof obj === 'function') {
        transitionManager.wait().then(function () {
          obj = obj();

          _this._run(b, callback);
        });
      } else {
        this._run(b, callback);
      }
    },
    _run: function _run(b, callback) {
      duration = obj.duration || 300;
      ease = obj.easing || linear;
      var program = {
        start: window.performance.now() + (obj.delay || 0),
        b: b,
        callback: callback || noop
      };

      if (intro && !initialised) {
        if (obj.css && obj.delay) {
          cssText = node.style.cssText;
          node.style.cssText += obj.css(0, 1);
        }

        if (obj.tick) obj.tick(0, 1);
        initialised = true;
      }

      if (!b) {
        program.group = outros.current;
        outros.current.remaining += 1;
      }

      if (obj.delay) {
        this.pending = program;
      } else {
        this.start(program);
      }

      if (!this.running) {
        this.running = true;
        transitionManager.add(this);
      }
    },
    start: function start(program) {
      component.fire((program.b ? 'intro' : 'outro') + ".start", {
        node: node
      });
      program.a = this.t;
      program.delta = program.b - program.a;
      program.duration = duration * Math.abs(program.b - program.a);
      program.end = program.start + program.duration;

      if (obj.css) {
        if (obj.delay) node.style.cssText = cssText;
        var rule = generateRule(program, ease, obj.css);
        transitionManager.addRule(rule, program.name = '__svelte_' + hash(rule));
        node.style.animation = (node.style.animation || '').split(', ').filter(function (anim) {
          return anim && (program.delta < 0 || !/__svelte/.test(anim));
        }).concat(program.name + " " + program.duration + "ms linear 1 forwards").join(', ');
      }

      this.program = program;
      this.pending = null;
    },
    update: function update(now) {
      var program = this.program;
      if (!program) return;
      var p = now - program.start;
      this.t = program.a + program.delta * ease(p / program.duration);
      if (obj.tick) obj.tick(this.t, 1 - this.t);
    },
    done: function done() {
      var program = this.program;
      this.t = program.b;
      if (obj.tick) obj.tick(this.t, 1 - this.t);
      component.fire((program.b ? 'intro' : 'outro') + ".end", {
        node: node
      });

      if (!program.b && !program.invalidated) {
        program.group.callbacks.push(function () {
          program.callback();
          if (obj.css) transitionManager.deleteRule(node, program.name);
        });

        if (--program.group.remaining === 0) {
          program.group.callbacks.forEach(run);
        }
      } else {
        if (obj.css) transitionManager.deleteRule(node, program.name);
      }

      this.running = !!this.pending;
    },
    abort: function abort(reset) {
      if (this.program) {
        if (reset && obj.tick) obj.tick(1, 0);
        if (obj.css) transitionManager.deleteRule(node, this.program.name);
        this.program = this.pending = null;
        this.running = false;
      }
    },
    invalidate: function invalidate() {
      if (this.program) {
        this.program.invalidated = true;
      }
    }
  };
}

var outros = {};

function groupOutros() {
  outros.current = {
    remaining: 0,
    callbacks: []
  };
}

var transitionManager = {
  running: false,
  transitions: [],
  bound: null,
  stylesheet: null,
  activeRules: {},
  promise: null,
  add: function add(transition) {
    this.transitions.push(transition);

    if (!this.running) {
      this.running = true;
      requestAnimationFrame(this.bound || (this.bound = this.next.bind(this)));
    }
  },
  addRule: function addRule(rule, name) {
    if (!this.stylesheet) {
      var style = createElement('style');
      document.head.appendChild(style);
      transitionManager.stylesheet = style.sheet;
    }

    if (!this.activeRules[name]) {
      this.activeRules[name] = true;
      this.stylesheet.insertRule("@keyframes " + name + " " + rule, this.stylesheet.cssRules.length);
    }
  },
  next: function next() {
    this.running = false;
    var now = window.performance.now();
    var i = this.transitions.length;

    while (i--) {
      var transition = this.transitions[i];

      if (transition.program && now >= transition.program.end) {
        transition.done();
      }

      if (transition.pending && now >= transition.pending.start) {
        transition.start(transition.pending);
      }

      if (transition.running) {
        transition.update(now);
        this.running = true;
      } else if (!transition.pending) {
        this.transitions.splice(i, 1);
      }
    }

    if (this.running) {
      requestAnimationFrame(this.bound);
    } else if (this.stylesheet) {
      var _i = this.stylesheet.cssRules.length;

      while (_i--) {
        this.stylesheet.deleteRule(_i);
      }

      this.activeRules = {};
    }
  },
  deleteRule: function deleteRule(node, name) {
    node.style.animation = node.style.animation.split(', ').filter(function (anim) {
      return anim && anim.indexOf(name) === -1;
    }).join(', ');
  },
  wait: function wait() {
    if (!transitionManager.promise) {
      transitionManager.promise = Promise.resolve();
      transitionManager.promise.then(function () {
        transitionManager.promise = null;
      });
    }

    return transitionManager.promise;
  }
};

function wrapAnimation(node, from, fn, params) {
  if (!from) return;
  var to = node.getBoundingClientRect();
  if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom) return;
  var info = fn(node, {
    from: from,
    to: to
  }, params);
  var duration = 'duration' in info ? info.duration : 300;
  var delay = 'delay' in info ? info.delay : 0;
  var ease = info.easing || linear;
  var start = window.performance.now() + delay;
  var end = start + duration;
  var program = {
    a: 0,
    t: 0,
    b: 1,
    delta: 1,
    duration: duration,
    start: start,
    end: end
  };
  var cssText = node.style.cssText;
  var animation = {
    pending: delay ? program : null,
    program: delay ? null : program,
    running: true,
    start: function start() {
      if (info.css) {
        if (delay) node.style.cssText = cssText;
        var rule = generateRule(program, ease, info.css);
        program.name = "__svelte_" + hash(rule);
        transitionManager.addRule(rule, program.name);
        node.style.animation = (node.style.animation || '').split(', ').filter(function (anim) {
          return anim && (program.delta < 0 || !/__svelte/.test(anim));
        }).concat(program.name + " " + program.duration + "ms linear 1 forwards").join(', ');
      }

      animation.program = program;
      animation.pending = null;
    },
    update: function update(now) {
      var p = now - program.start;
      var t = program.a + program.delta * ease(p / program.duration);
      if (info.tick) info.tick(t, 1 - t);
    },
    done: function done() {
      if (info.tick) info.tick(1, 0);
      animation.stop();
    },
    stop: function stop() {
      if (info.css) transitionManager.deleteRule(node, program.name);
      animation.running = false;
    }
  };
  transitionManager.add(animation);
  if (info.tick) info.tick(0, 1);

  if (delay) {
    if (info.css) node.style.cssText += info.css(0, 1);
  } else {
    animation.start();
  }

  return animation;
}

function fixPosition(node) {
  var style = getComputedStyle(node);

  if (style.position !== 'absolute' && style.position !== 'fixed') {
    var width = style.width,
        height = style.height;
    var a = node.getBoundingClientRect();
    node.style.position = 'absolute';
    node.style.width = width;
    node.style.height = height;
    var b = node.getBoundingClientRect();

    if (a.left !== b.left || a.top !== b.top) {
      var _style = getComputedStyle(node);

      var transform = _style.transform === 'none' ? '' : _style.transform;
      node.style.transform = transform + " translate(" + (a.left - b.left) + "px, " + (a.top - b.top) + "px)";
    }
  }
}

function handlePromise(promise, info) {
  var token = info.token = {};

  function update(type, index, key, value) {
    var _ref2;

    if (info.token !== token) return;
    info.resolved = key && (_ref2 = {}, _ref2[key] = value, _ref2);
    var child_ctx = assign(assign({}, info.ctx), info.resolved);
    var block = type && (info.current = type)(info.component, child_ctx);

    if (info.block) {
      if (info.blocks) {
        info.blocks.forEach(function (block, i) {
          if (i !== index && block) {
            groupOutros();
            block.o(function () {
              block.d(1);
              info.blocks[i] = null;
            });
          }
        });
      } else {
        info.block.d(1);
      }

      block.c();
      block[block.i ? 'i' : 'm'](info.mount(), info.anchor);
      info.component.root.set({}); // flush any handlers that were created
    }

    info.block = block;
    if (info.blocks) info.blocks[index] = block;
  }

  if (isPromise(promise)) {
    promise.then(function (value) {
      update(info.then, 1, info.value, value);
    }, function (error) {
      update(info["catch"], 2, info.error, error);
    }); // if we previously had a then/catch block, destroy it

    if (info.current !== info.pending) {
      update(info.pending, 0);
      return true;
    }
  } else {
    var _info$resolved;

    if (info.current !== info.then) {
      update(info.then, 1, info.value, promise);
      return true;
    }

    info.resolved = (_info$resolved = {}, _info$resolved[info.value] = promise, _info$resolved);
  }
}

function destroyBlock(block, lookup) {
  block.d(1);
  lookup[block.key] = null;
}

function outroAndDestroyBlock(block, lookup) {
  block.o(function () {
    destroyBlock(block, lookup);
  });
}

function fixAndOutroAndDestroyBlock(block, lookup) {
  block.f();
  outroAndDestroyBlock(block, lookup);
}

function updateKeyedEach(old_blocks, component, changed, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, intro_method, next, get_context) {
  var o = old_blocks.length;
  var n = list.length;
  var i = o;
  var old_indexes = {};

  while (i--) {
    old_indexes[old_blocks[i].key] = i;
  }

  var new_blocks = [];
  var new_lookup = {};
  var deltas = {};
  var i = n;

  while (i--) {
    var child_ctx = get_context(ctx, list, i);
    var key = get_key(child_ctx);
    var block = lookup[key];

    if (!block) {
      block = create_each_block(component, key, child_ctx);
      block.c();
    } else if (dynamic) {
      block.p(changed, child_ctx);
    }

    new_blocks[i] = new_lookup[key] = block;
    if (key in old_indexes) deltas[key] = Math.abs(i - old_indexes[key]);
  }

  var will_move = {};
  var did_move = {};

  function insert(block) {
    block[intro_method](node, next);
    lookup[block.key] = block;
    next = block.first;
    n--;
  }

  while (o && n) {
    var new_block = new_blocks[n - 1];
    var old_block = old_blocks[o - 1];
    var new_key = new_block.key;
    var old_key = old_block.key;

    if (new_block === old_block) {
      // do nothing
      next = new_block.first;
      o--;
      n--;
    } else if (!new_lookup[old_key]) {
      // remove old block
      destroy(old_block, lookup);
      o--;
    } else if (!lookup[new_key] || will_move[new_key]) {
      insert(new_block);
    } else if (did_move[old_key]) {
      o--;
    } else if (deltas[new_key] > deltas[old_key]) {
      did_move[new_key] = true;
      insert(new_block);
    } else {
      will_move[old_key] = true;
      o--;
    }
  }

  while (o--) {
    var old_block = old_blocks[o];
    if (!new_lookup[old_block.key]) destroy(old_block, lookup);
  }

  while (n) {
    insert(new_blocks[n - 1]);
  }

  return new_blocks;
}

function measure(blocks) {
  var rects = {};
  var i = blocks.length;

  while (i--) {
    rects[blocks[i].key] = blocks[i].node.getBoundingClientRect();
  }

  return rects;
}

function animate(blocks, rects, fn, params) {
  var i = blocks.length;

  while (i--) {
    var block = blocks[i];
    var from = rects[block.key];
    if (!from) continue;
    var to = block.node.getBoundingClientRect();
    if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom) continue;
  }
}

function getSpreadUpdate(levels, updates) {
  var update = {};
  var to_null_out = {};
  var accounted_for = {};
  var i = levels.length;

  while (i--) {
    var o = levels[i];
    var n = updates[i];

    if (n) {
      for (var key in o) {
        if (!(key in n)) to_null_out[key] = 1;
      }

      for (var key in n) {
        if (!accounted_for[key]) {
          update[key] = n[key];
          accounted_for[key] = 1;
        }
      }

      levels[i] = n;
    } else {
      for (var key in o) {
        accounted_for[key] = 1;
      }
    }
  }

  for (var key in to_null_out) {
    if (!(key in update)) update[key] = undefined;
  }

  return update;
} // https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
// https://infra.spec.whatwg.org/#noncharacter


var invalidAttributeNameCharacter = /(?:[\t-\r "'\/=>\xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFDD0-\uFDEF\uFEFF\uFFFE\uFFFF]|[\uD83F\uD87F\uD8BF\uD8FF\uD93F\uD97F\uD9BF\uD9FF\uDA3F\uDA7F\uDABF\uDAFF\uDB3F\uDB7F\uDBBF\uDBFF][\uDFFE\uDFFF])/;

function spread(args) {
  var attributes = Object.assign.apply(Object, [{}].concat(args));
  var str = '';
  Object.keys(attributes).forEach(function (name) {
    if (invalidAttributeNameCharacter.test(name)) return;
    var value = attributes[name];
    if (value === undefined) return;
    if (value === true) str += " " + name;
    var escaped = String(value).replace(/"/g, '&#34;').replace(/'/g, '&#39;');
    str += " " + name + "=" + JSON.stringify(escaped);
  });
  return str;
}

var escaped = {
  '"': '&quot;',
  "'": '&#39;',
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;'
};

function escape(html) {
  return String(html).replace(/["'&<>]/g, function (match) {
    return escaped[match];
  });
}

function each(items, assign, fn) {
  var str = '';

  for (var i = 0; i < items.length; i += 1) {
    str += fn(assign(items[i], i));
  }

  return str;
}

var missingComponent = {
  _render: function _render() {
    return '';
  }
};

function validateSsrComponent(component, name) {
  if (!component || !component._render) {
    if (name === 'svelte:component') name += ' this={...}';
    throw new Error("<" + name + "> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules");
  }

  return component;
}

function debug(file, line, column, values) {
  console.log("{@debug} " + (file ? file + ' ' : '') + "(" + line + ":" + column + ")");
  console.log(values);
  return '';
}

function blankObject() {
  return Object.create(null);
}

function destroy(detach) {
  this.destroy = noop;
  this.fire('destroy');
  this.set = noop;

  this._fragment.d(detach !== false);

  this._fragment = null;
  this._state = {};
}

function destroyDev(detach) {
  destroy.call(this, detach);

  this.destroy = function () {
    console.warn('Component was already destroyed');
  };
}

function _differs(a, b) {
  return a != a ? b == b : a !== b || a && typeof a === 'object' || typeof a === 'function';
}

function _differsImmutable(a, b) {
  return a != a ? b == b : a !== b;
}

function fire(eventName, data) {
  var handlers = eventName in this._handlers && this._handlers[eventName].slice();

  if (!handlers) return;

  for (var i = 0; i < handlers.length; i += 1) {
    var handler = handlers[i];

    if (!handler.__calling) {
      try {
        handler.__calling = true;
        handler.call(this, data);
      } finally {
        handler.__calling = false;
      }
    }
  }
}

function flush(component) {
  component._lock = true;
  callAll(component._beforecreate);
  callAll(component._oncreate);
  callAll(component._aftercreate);
  component._lock = false;
}

function get() {
  return this._state;
}

function init(component, options) {
  component._handlers = blankObject();
  component._slots = blankObject();
  component._bind = options._bind;
  component._staged = {};
  component.options = options;
  component.root = options.root || component;
  component.store = options.store || component.root.store;

  if (!options.root) {
    component._beforecreate = [];
    component._oncreate = [];
    component._aftercreate = [];
  }
}

function on(eventName, handler) {
  var handlers = this._handlers[eventName] || (this._handlers[eventName] = []);
  handlers.push(handler);
  return {
    cancel: function cancel() {
      var index = handlers.indexOf(handler);
      if (~index) handlers.splice(index, 1);
    }
  };
}

function set(newState) {
  this._set(assign({}, newState));

  if (this.root._lock) return;
  flush(this.root);
}

function _set(newState) {
  var oldState = this._state,
      changed = {},
      dirty = false;
  newState = assign(this._staged, newState);
  this._staged = {};

  for (var key in newState) {
    if (this._differs(newState[key], oldState[key])) changed[key] = dirty = true;
  }

  if (!dirty) return;
  this._state = assign(assign({}, oldState), newState);

  this._recompute(changed, this._state);

  if (this._bind) this._bind(changed, this._state);

  if (this._fragment) {
    this.fire("state", {
      changed: changed,
      current: this._state,
      previous: oldState
    });

    this._fragment.p(changed, this._state);

    this.fire("update", {
      changed: changed,
      current: this._state,
      previous: oldState
    });
  }
}

function _stage(newState) {
  assign(this._staged, newState);
}

function setDev(newState) {
  if (typeof newState !== 'object') {
    throw new Error(this._debugName + '.set was called without an object of data key-values to update.');
  }

  this._checkReadOnly(newState);

  set.call(this, newState);
}

function callAll(fns) {
  while (fns && fns.length) {
    fns.shift()();
  }
}

function _mount(target, anchor) {
  this._fragment[this._fragment.i ? 'i' : 'm'](target, anchor || null);
}

var PENDING = {};
var SUCCESS = {};
var FAILURE = {};

function removeFromStore() {
  this.store._remove(this);
}

var proto = {
  destroy: destroy,
  get: get,
  fire: fire,
  on: on,
  set: set,
  _recompute: noop,
  _set: _set,
  _stage: _stage,
  _mount: _mount,
  _differs: _differs
};
var protoDev = {
  destroy: destroyDev,
  get: get,
  fire: fire,
  on: on,
  set: setDev,
  _recompute: noop,
  _set: _set,
  _stage: _stage,
  _mount: _mount,
  _differs: _differs
};


/***/ }),

/***/ "../node_modules/svelte/store.js":
/*!***************************************!*\
  !*** ../node_modules/svelte/store.js ***!
  \***************************************/
/*! exports provided: Store */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Store", function() { return Store; });
/* harmony import */ var core_js_modules_web_dom_collections_for_each__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/web.dom-collections.for-each */ "../node_modules/core-js/modules/web.dom-collections.for-each.js");
/* harmony import */ var core_js_modules_web_dom_collections_for_each__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_web_dom_collections_for_each__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _shared_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./shared.js */ "../node_modules/svelte/shared.js");



function Store(state, options) {
  this._handlers = {};
  this._dependents = [];
  this._computed = Object(_shared_js__WEBPACK_IMPORTED_MODULE_1__["blankObject"])();
  this._sortedComputedProperties = [];
  this._state = Object(_shared_js__WEBPACK_IMPORTED_MODULE_1__["assign"])({}, state);
  this._differs = options && options.immutable ? _shared_js__WEBPACK_IMPORTED_MODULE_1__["_differsImmutable"] : _shared_js__WEBPACK_IMPORTED_MODULE_1__["_differs"];
}

Object(_shared_js__WEBPACK_IMPORTED_MODULE_1__["assign"])(Store.prototype, {
  _add: function _add(component, props) {
    this._dependents.push({
      component: component,
      props: props
    });
  },
  _init: function _init(props) {
    var state = {};

    for (var i = 0; i < props.length; i += 1) {
      var prop = props[i];
      state['$' + prop] = this._state[prop];
    }

    return state;
  },
  _remove: function _remove(component) {
    var i = this._dependents.length;

    while (i--) {
      if (this._dependents[i].component === component) {
        this._dependents.splice(i, 1);

        return;
      }
    }
  },
  _set: function _set(newState, changed) {
    var _this = this;

    var previous = this._state;
    this._state = Object(_shared_js__WEBPACK_IMPORTED_MODULE_1__["assign"])(Object(_shared_js__WEBPACK_IMPORTED_MODULE_1__["assign"])({}, previous), newState);

    for (var i = 0; i < this._sortedComputedProperties.length; i += 1) {
      this._sortedComputedProperties[i].update(this._state, changed);
    }

    this.fire('state', {
      changed: changed,
      previous: previous,
      current: this._state
    });

    this._dependents.filter(function (dependent) {
      var componentState = {};
      var dirty = false;

      for (var j = 0; j < dependent.props.length; j += 1) {
        var prop = dependent.props[j];

        if (prop in changed) {
          componentState['$' + prop] = _this._state[prop];
          dirty = true;
        }
      }

      if (dirty) {
        dependent.component._stage(componentState);

        return true;
      }
    }).forEach(function (dependent) {
      dependent.component.set({});
    });

    this.fire('update', {
      changed: changed,
      previous: previous,
      current: this._state
    });
  },
  _sortComputedProperties: function _sortComputedProperties() {
    var computed = this._computed;
    var sorted = this._sortedComputedProperties = [];
    var visited = Object(_shared_js__WEBPACK_IMPORTED_MODULE_1__["blankObject"])();
    var currentKey;

    function visit(key) {
      var c = computed[key];

      if (c) {
        c.deps.forEach(function (dep) {
          if (dep === currentKey) {
            throw new Error("Cyclical dependency detected between " + dep + " <-> " + key);
          }

          visit(dep);
        });

        if (!visited[key]) {
          visited[key] = true;
          sorted.push(c);
        }
      }
    }

    for (var key in this._computed) {
      visit(currentKey = key);
    }
  },
  compute: function compute(key, deps, fn) {
    var _this2 = this;

    var value;
    var c = {
      deps: deps,
      update: function update(state, changed, dirty) {
        var values = deps.map(function (dep) {
          if (dep in changed) dirty = true;
          return state[dep];
        });

        if (dirty) {
          var newValue = fn.apply(null, values);

          if (_this2._differs(newValue, value)) {
            value = newValue;
            changed[key] = true;
            state[key] = value;
          }
        }
      }
    };
    this._computed[key] = c;

    this._sortComputedProperties();

    var state = Object(_shared_js__WEBPACK_IMPORTED_MODULE_1__["assign"])({}, this._state);
    var changed = {};
    c.update(state, changed, true);

    this._set(state, changed);
  },
  fire: _shared_js__WEBPACK_IMPORTED_MODULE_1__["fire"],
  get: _shared_js__WEBPACK_IMPORTED_MODULE_1__["get"],
  on: _shared_js__WEBPACK_IMPORTED_MODULE_1__["on"],
  set: function set(newState) {
    var oldState = this._state;
    var changed = this._changed = {};
    var dirty = false;

    for (var key in newState) {
      if (this._computed[key]) throw new Error("'" + key + "' is a read-only computed property");
      if (this._differs(newState[key], oldState[key])) changed[key] = dirty = true;
    }

    if (!dirty) return;

    this._set(newState, changed);
  }
});


/***/ })

}]);